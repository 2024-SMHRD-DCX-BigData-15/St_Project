<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="새우양식 관제시스템 대시보드" />
    <link rel="stylesheet" href="/css/dashboarddetail.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>관제센터 대시보드</title>
  </head>
  <body>
    <!-- 햄버거 버튼 -->
    <button class="hamburger-btn" id="hamburgerBtn">☰</button>

    <!-- 사이드바 -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>메뉴</h2>
      </div>
      <ul class="sidebar-menu">
        <!-- 홈 -->
        <li>
          <a href="/maindashboard" class="toggle-menu">홈</a>
        </li>
        <!-- 수조 정보 등록 -->
        <li>
          <a href="/tank" class="toggle-menu">수조 정보 등록</a>
        </li>
        <!-- 알람 히스토리 -->
        <li>
          <a href="/alarmHistory2" class="toggle-menu">알람 히스토리</a>
        </li>
        <!-- 회원 정보 관리 -->
        <li>
          <a href="javascript:void(0)" class="toggle-menu">회원 정보 관리</a>
          <ul class="sub-menu">
            <li><a th:href="@{/edit/{id}(id=${session.loginUser.userId})}">회원 정보 수정</a></li>
            <li><a href="/delete">회원 탈퇴</a></li>
          </ul>
        </li>
      </ul>
    </div>

    <!-- 메인 콘텐츠 -->
    <main class="main-content">
      <header class="header">
        <h1 class="page-title">세부관제시스템</h1>
        <div class="user-info">
          <div th:if="${session.loginUser != null}">
            <p th:text="${session.loginUser.userId}"></p> <!-- 로그인된 사용자 이름 출력 -->
          </div>
          <button class="logout-btn" onclick="handleLogout()">로그아웃</button> <!-- ✅ 수정된 로그아웃 버튼 -->
        </div>
      </header>

      <!-- 6개의 데이터 카드 -->
      <!-- 데이터 표시 -->
      <section class="dashboard-cards">
        <!-- 산성도 -->
        <div class="card card-ph">
          <h4>산성도</h4>
          <div class="data-container">
            <canvas id="chart-1" width="200" height="200"></canvas>
          </div>
        </div>

        <!-- 용존산소 -->
        <div class="card card-oxygen">
          <h4>용존산소</h4>
          <div class="data-container">
            <canvas id="chart-2" width="200" height="200"></canvas>
          </div>
        </div>

        <!-- 수온 -->
        <div class="card card-temperature">
          <h4>수온</h4>
          <div class="data-container">
            <canvas id="chart-3" width="200" height="200"></canvas>
          </div>
        </div>

        <!-- 염도 -->
        <div class="card card-salinity">
          <h4>염도</h4>
          <div class="data-container">
            <canvas id="chart-4" width="200" height="200"></canvas>
          </div>
        </div>

        <!-- 암모니아 -->
        <div class="card card-ammonia">
          <h4>암모니아</h4>
          <div class="data-container">
            <canvas id="chart-5" width="200" height="200"></canvas>
          </div>
        </div>

        <!-- 아질산 -->
        <div class="card card-nitrite">
          <h4>아질산</h4>
          <div class="data-container">
            <canvas id="chart-6" width="200" height="200"></canvas>
          </div>
        </div>
      </section>

      <!-- 수조정보와 실시간 그래프 -->
      <section class="dashboard-cards">
        <div class="tank-info">
          <h4>수조정보</h4><br>
          <p><strong>수조 ID:</strong> <span th:text="${selectedTank?.tankIdx ?: '정보 없음'}"></span></p>
          <p><strong>직경:</strong> <span th:text="${selectedTank?.tankWidth ?: '정보 없음'}"></span> m</p>
          <p><strong>높이:</strong> <span th:text="${selectedTank?.tankHeight ?: '정보 없음'}"></span> m</p>
          <p><strong>위치:</strong> <span th:text="${selectedTank?.tankLocation ?: '정보 없음'}"></span></p>
          <p><strong>품종:</strong> <span th:text="${selectedTank?.fishType ?: '정보 없음'}"></span></p>
          <p><strong>사육 개시일:</strong><span th:text="${selectedTank?.startedAt != null ? #temporals.format(selectedTank.startedAt, 'yyyy-MM-dd') : '정보 없음'}"></span></p>
          <canvas id="tank-data"></canvas>
        </div>
        <div class="card card-graph">
          <div class="graph-container">
            <!-- AI 허브 데이터를 활용한 그래프 삽입 영역 /30초마다 변경되게 -->
            <canvas id="aihubGraph"></canvas>
          </div>
        </div>
      </section>
    </main>

    <script>
      // 전역 변수 정의
      const dataRanges = {
        'chart-1': { min: 7.5, max: 9.0, label: 'pH' }, // 산성도
        'chart-2': { min: 5.0, max: 10.0, label: 'O₂ (mg/L)' }, // 용존산소
        'chart-3': { min: 26.0, max: 38.0, label: '°C' }, // 수온
        'chart-4': { min: 0.5, max: 45.0, label: 'ppt' }, // 염도
        'chart-5': { min: 0.0, max: 0.16, label: 'NH₃ (mg/L)' }, // 암모니아
        'chart-6': { min: 0.0, max: 0.5, label: 'NO₂ (mg/L)' }, // 아질산
      };

      let currentValues = {
        'chart-1': null,
        'chart-2': null,
        'chart-3': null,
        'chart-4': null,
        'chart-5': null,
        'chart-6': null,
      };

      let realtimeChart = null; // 현재 그래프 저장용

      /**
       * 🔹 로그아웃 함수 (쿠키 삭제 후 서버 요청)
       */
      function handleLogout() {
        console.log("🚀 로그아웃 요청");

        // ✅ 자동 로그인 관련 쿠키 삭제
        deleteCookie("autoLoginId");
        deleteCookie("autoLoginPw");

        // ✅ 로그아웃 요청 보내기
        fetch("/logout", { method: "GET" })
          .then(() => {
            alert("로그아웃 완료!");
            window.location.href = "/login"; // 로그인 페이지로 이동
          });
      }

      /**
       * 🔹 쿠키 삭제 함수
       */
      function deleteCookie(name) {
        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;SameSite=Strict;Secure`;
      }

      // 햄버거 버튼으로 사이드바 토글
      document.getElementById("hamburgerBtn").addEventListener("click", () => {
        document.getElementById("sidebar").classList.toggle("active");
      });

      // 서브 메뉴 토글 기능
      const toggleMenus = document.querySelectorAll(".toggle-menu");
      toggleMenus.forEach(menu => {
        menu.addEventListener("click", (e) => {
          const subMenu = menu.nextElementSibling;
          if (subMenu && subMenu.classList.contains("sub-menu")) {
            e.preventDefault(); // 링크 기본 동작 방지
            subMenu.style.display = subMenu.style.display === "block" ? "none" : "block";
          }
        });
      });

      // 알림 로그
      function toggleNotifications() {
        var log = document.getElementById("notificationLog");
        if (log) {
          log.style.display = log.style.display === "block" ? "none" : "block";
        }
      }

      // "수조 관리"와 "회원 정보 관리"를 클릭할 때 sub-menu 열기
      document.querySelectorAll('.toggle-menu').forEach(menu => {
        menu.addEventListener('click', function() {
          const subMenu = this.nextElementSibling;
          if (subMenu && subMenu.classList.contains("sub-menu")) {
            if (subMenu.classList.contains('open')) {
              subMenu.classList.remove('open');
            } else {
              document.querySelectorAll('.sub-menu').forEach(menu => {
                menu.classList.remove('open');
              });
              subMenu.classList.add('open');
            }
          }
        });
      });

      //---------------------------------------------화살표 표시-----------------------------------------------
      document.addEventListener("DOMContentLoaded", function () {
        // 전역 변수 정의
        const canvasElements = [
          document.getElementById('chart-1'),
          document.getElementById('chart-2'),
          document.getElementById('chart-3'),
          document.getElementById('chart-4'),
          document.getElementById('chart-5'),
          document.getElementById('chart-6'),
        ];

        // 각 캔버스별 현재 각도와 목표 각도 관리
        const angles = {
          'chart-1': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-2': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-3': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-4': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-5': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-6': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        };

        // 애니메이션 진행 상태 관리
        const animationStates = {
          'chart-1': { animating: false },
          'chart-2': { animating: false },
          'chart-3': { animating: false },
          'chart-4': { animating: false },
          'chart-5': { animating: false },
          'chart-6': { animating: false },
        };

        // 이징 함수 (easeOutQuad)
        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }

        // 게이지 업데이트 함수 (부드러운 애니메이션 추가)
        function updateGauge(chartId, value, min, max) {
          if (value === null || value === undefined || isNaN(value)) {
            console.warn(`updateGauge: 유효하지 않은 값 - chartId: ${chartId}, value: ${value}`);
            return;
          }

          // currentValues 갱신
          currentValues[chartId] = value;

          const percentage = ((value - min) / (max - min)) * 100;
          const targetAngle = Math.PI + (percentage / 100) * Math.PI;
          angles[chartId].target = targetAngle;

          // 애니메이션 시작
          if (!animationStates[chartId].animating) {
            animationStates[chartId].animating = true;
            animateGauge(chartId);
          }
        }

        // 애니메이션 함수
        function animateGauge(chartId) {
          const canvas = document.getElementById(chartId);
          const ctx = canvas.getContext("2d");
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          const startAngle = angles[chartId].current;
          const targetAngle = angles[chartId].target;
          const duration = 1000; // 애니메이션 지속 시간 (1초)
          let startTime = null;

          function step(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1); // 0에서 1까지 진행
            const easedProgress = easeOutQuad(progress);

            // 현재 각도를 목표 각도로 보간
            angles[chartId].current = startAngle + (targetAngle - startAngle) * easedProgress;

            // 캔버스 지우기
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // 배경 게이지 그리기
            drawGaugeOnCanvas(chartId, canvas);

            // 화살표 그리기
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight - 50;
            const len = 80;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angles[chartId].current) * len, centerY + Math.sin(angles[chartId].current) * len);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 4;
            ctx.stroke();

            // 데이터 값 그리기 (화살표 시작점과 게이지 사이에 위치)
            const value = currentValues[chartId] ? currentValues[chartId].toFixed(3) : '-'; // 소수점 3자리까지 표시
            ctx.fillStyle = '#fff'; // 텍스트 색상 (흰색)
            ctx.font = 'bold 20px Arial'; // 텍스트 스타일
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const radius = 100; // 게이지 반지름 (drawGaugeOnCanvas에서 정의됨)
            const textY = centerY - radius / 3; // 화살표 시작점과 게이지 사이에 위치
            ctx.fillText(value, centerX, textY);

            // 애니메이션이 끝나지 않았으면 계속 진행
            if (progress < 1) {
              requestAnimationFrame(step);
            } else {
              animationStates[chartId].animating = false;
            }
          }

          requestAnimationFrame(step);
        }

        // 게이지 배경 그리기 함수
        function drawGaugeOnCanvas(canvasId, canvas) {
          const ctx = canvas.getContext('2d');
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;
          const centerX = canvasWidth / 2;
          const centerY = canvasHeight - 50;
          const radius = 100;
          const gaugeWidth = 30;

          const colors = {
            normal: ['#32cd32', '#90ee90'],
            warning: ['#ffa500', '#ffd580'],
            danger: ['#ff4500', '#ff7f7f']
          };

          const fixedData = {
            normal: 33,
            warning: 33,
            danger: 34
          };

          const labels = {
            normal: '정상',
            warning: '경고',
            danger: '위험'
          };

          function drawGauge() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            const totalAngle = Math.PI;
            const startAngle = Math.PI;
            const total = fixedData.normal + fixedData.warning + fixedData.danger;
            const normalAngle = (fixedData.normal / total) * totalAngle;
            const warningAngle = (fixedData.warning / total) * totalAngle;
            const dangerAngle = (fixedData.danger / total) * totalAngle;

            let currentAngle = startAngle;

            // 그림자 설정
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;

            // 게이지 그리기
            drawSection(currentAngle, normalAngle, colors.normal);
            currentAngle += normalAngle;
            drawSection(currentAngle, warningAngle, colors.warning);
            currentAngle += warningAngle;
            drawSection(currentAngle, dangerAngle, colors.danger);

            ctx.shadowBlur = 0; // 그림자 해제

            drawLabels(startAngle, normalAngle, warningAngle, dangerAngle);
          }

          function drawSection(start, angle, colorPair) {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
            gradient.addColorStop(0, colorPair[0]);
            gradient.addColorStop(1, colorPair[1]);

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, start, start + angle);
            ctx.arc(centerX, centerY, radius - gaugeWidth, start + angle, start, true);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#333'; // 테두리
            ctx.stroke();
          }

          function drawLabels(startAngle, normalAngle, warningAngle, dangerAngle) {
            const labelRadius = radius - gaugeWidth / 2;
            ctx.fillStyle = '#000';
            ctx.font = 'bold 15px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const angles = [
              startAngle + normalAngle / 2,
              startAngle + normalAngle + warningAngle / 2,
              startAngle + normalAngle + warningAngle + dangerAngle / 2
            ];
            const texts = [labels.normal, labels.warning, labels.danger];

            angles.forEach((angle, i) => {
              const x = centerX + Math.cos(angle) * labelRadius;
              const y = centerY + Math.sin(angle) * labelRadius;
              ctx.fillText(texts[i], x, y);
            });
          }

          drawGauge();
        }

        // 초기 캔버스 그리기
        canvasElements.forEach(canvas => {
          drawGaugeOnCanvas(canvas.id, canvas);
        });

        // 최신 수조 데이터 가져오기
        function fetchLatestTankData() {
          const urlParams = new URLSearchParams(window.location.search);
          const tankIdx = urlParams.get("tankIdx");

          if (tankIdx) {
            fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
              .then(response => {
                if (!response.ok) {
                  throw new Error(`❌ HTTP 오류: ${response.status}`);
                }
                return response.json();
              })
              .then(data => {
                console.log("✅ 최신 수조 데이터 로드 완료:", data);

                // currentValues 업데이트
                currentValues['chart-1'] = parseFloat(data.waterPh);
                currentValues['chart-2'] = parseFloat(data.waterDo);
                currentValues['chart-3'] = parseFloat(data.waterTemp);
                currentValues['chart-4'] = parseFloat(data.waterSalt);
                currentValues['chart-5'] = parseFloat(data.waterAmmonia);
                currentValues['chart-6'] = parseFloat(data.waterNitrogen);

                // 화살표 업데이트 (부드러운 애니메이션)
                updateGauge('chart-1', currentValues['chart-1'], dataRanges['chart-1'].min, dataRanges['chart-1'].max);
                updateGauge('chart-2', currentValues['chart-2'], dataRanges['chart-2'].min, dataRanges['chart-2'].max);
                updateGauge('chart-3', currentValues['chart-3'], dataRanges['chart-3'].min, dataRanges['chart-3'].max);
                updateGauge('chart-4', currentValues['chart-4'], dataRanges['chart-4'].min, dataRanges['chart-4'].max);
                updateGauge('chart-5', currentValues['chart-5'], dataRanges['chart-5'].min, dataRanges['chart-5'].max);
                updateGauge('chart-6', currentValues['chart-6'], dataRanges['chart-6'].min, dataRanges['chart-6'].max);
              })
              .catch(error => {
                console.error("❌ 수조 데이터 로드 실패:", error);
              });
          } else {
            console.warn("tankIdx가 URL에 없습니다.");
          }
        }

        // 페이지 로드 후 데이터 가져오기 시작
        fetchLatestTankData();

        // 24시간마다 자동 갱신
        setInterval(fetchLatestTankData, 1000*60*60*24);
      });

      //---------------------[최신 수질 데이터 불러오기 자동 새로고침 백엔드 스크립트]------------------------
      function startAutoRefresh() {
        fetchLatestTankData();
        setInterval(fetchLatestTankData, 1000*60*60*24);
      }

      // 페이지가 완전히 로드된 후 자동 갱신 시작
      document.addEventListener("DOMContentLoaded", startAutoRefresh);

      // 클릭 이벤트 및 실시간 데이터
      const cardElements = document.querySelectorAll('.card');
      let labelsMap = {};
      let valuesMap = {};

      cardElements.forEach(card => {
        const canvas = card.querySelector('canvas');
        const chartId = canvas.id;
        labelsMap[chartId] = [];
        valuesMap[chartId] = [];

        card.addEventListener('click', () => {
          cardElements.forEach(c => {
            c.classList.remove('clicked', 'animate-click');
          });

          card.classList.add('clicked', 'animate-click');
          setTimeout(() => {
            card.classList.remove('animate-click');
          }, 300);

          const label = dataRanges[chartId].label;
          showGraphFor(chartId, label);
        });
      });

      // 초기 빈 그래프 설정
      window.onload = function() {
        const ctx = document.getElementById('aihubGraph').getContext('2d');
        realtimeChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [{
              label: '데이터 없음',
              data: [],
              borderColor: '#4A90E2',
              backgroundColor: 'rgba(74, 144, 226, 0.2)',
              fill: true,
              tension: 0.3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: '실시간 데이터',
                  color: '#ffffff',
                  font: { size: 14 }
                },
                ticks: { display: true, color: '#ffffff', font: { size: 12 } }
              },
              y: {
                title: { display: false },
                ticks: { color: '#ffffff', font: { size: 12 }, padding: 10 }
              }
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                color: '#ffffff',
                font: { size: 16 },
                padding: { top: 10, bottom: 20 }
              }
            }
          }
        });
      };

      // 그래프 출력 함수
      function showGraphFor(chartId, label) {
        const ctx = document.getElementById('aihubGraph').getContext('2d');
        const valueKeyMap = {
          'chart-1': 'waterPh',
          'chart-2': 'waterDo',
          'chart-3': 'waterTemp',
          'chart-4': 'waterSalt',
          'chart-5': 'waterAmmonia',
          'chart-6': 'waterNitrogen'
        };
        const dataKey = valueKeyMap[chartId];

        if (realtimeChart) {
          realtimeChart.destroy();
        }

        realtimeChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labelsMap[chartId],
            datasets: [{
              label: `${label} 실시간 데이터`,
              data: valuesMap[chartId],
              borderColor: '#4A90E2',
              backgroundColor: 'rgba(74, 144, 226, 0.2)',
              fill: true,
              tension: 0.3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: '실시간 데이터',
                  color: '#ffffff',
                  font: { size: 14 }
                },
                ticks: { display: true, color: '#ffffff', font: { size: 12 } }
              },
              y: {
                title: { display: false },
                ticks: { color: '#ffffff', font: { size: 12 } }
              }
            },
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: label,
                color: '#ffffff',
                font: { size: 16 },
                padding: { top: 10, bottom: 20 }
              }
            }
          }
        });

        // 즉시 데이터 불러오기
        fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);

        // 기존 setInterval 제거 (중복 방지)
        if (window.graphInterval) {
          clearInterval(window.graphInterval);
        }

        // 24시간마다 갱신
        window.graphInterval = setInterval(() => {
          fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);
        }, 1000*60*60*24);
      }

      // 서버에서 데이터 받아 그래프 갱신
      function fetchLatestTankDataForGraph(chartId, dataKey, labels, values, chart) {
        const urlParams = new URLSearchParams(window.location.search);
        const tankIdx = urlParams.get("tankIdx");

        if (tankIdx) {
          fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
            .then(response => response.json())
            .then(data => {
              const value = parseFloat(data[dataKey]);
              const now = new Date();
              const timeLabel = now.toLocaleTimeString();

              if (!isNaN(value)) {
                labels.push(timeLabel);
                values.push(value);

                if (labels.length > 10) {
                  labels.shift();
                  values.shift();
                }

                chart.data.labels = labels;
                chart.data.datasets[0].data = values;
                chart.update();
              }
            })
            .catch(err => console.error("❌ 그래프 데이터 로드 실패:", err));
        }
      }
    </script>
  </body>
</html>