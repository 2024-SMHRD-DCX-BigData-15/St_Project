<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="ìƒˆìš°ì–‘ì‹ ê´€ì œì‹œìŠ¤í…œ ëŒ€ì‹œë³´ë“œ" />
    <link rel="stylesheet" href="/css/dashboarddetail.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>ê´€ì œì„¼í„° ëŒ€ì‹œë³´ë“œ</title>
  </head>
  <body>
    <!-- í–„ë²„ê±° ë²„íŠ¼ -->
    <button class="hamburger-btn" id="hamburgerBtn">â˜°</button>

    <!-- ì‚¬ì´ë“œë°” -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>ë©”ë‰´</h2>
      </div>
      <ul class="sidebar-menu">
        <li><a href="/maindashboard" class="toggle-menu">í™ˆ</a></li>
        <li><a href="/tank" class="toggle-menu">ìˆ˜ì¡° ì •ë³´ ë“±ë¡</a></li>
        <li><a href="/alarmHistory2" class="toggle-menu">ì•ŒëŒ íˆìŠ¤í† ë¦¬</a></li>
        <li>
          <a href="javascript:void(0)" class="toggle-menu">íšŒì› ì •ë³´ ê´€ë¦¬</a>
          <ul class="sub-menu">
            <li><a th:href="@{/edit/{id}(id=${session.loginUser.userId})}">íšŒì› ì •ë³´ ìˆ˜ì •</a></li>
            <li><a href="/delete">íšŒì› íƒˆí‡´</a></li>
          </ul>
        </li>
      </ul>
    </div>

    <!-- ë©”ì¸ ì½˜í…ì¸  -->
    <main class="main-content">
      <header class="header">
        <h1 class="page-title">ì„¸ë¶€ê´€ì œì‹œìŠ¤í…œ</h1>
        <div class="user-info">
          <div th:if="${session.loginUser != null}">
            <p th:text="${session.loginUser.userId}"></p>
          </div>
          <button class="logout-btn" onclick="handleLogout()">ë¡œê·¸ì•„ì›ƒ</button>
        </div>
      </header>

      <!-- ë°ì´í„° ì¹´ë“œ -->
      <section class="dashboard-cards">
        <div class="card card-ph">
          <h4>ì‚°ì„±ë„</h4>
          <div class="data-container">
            <canvas id="chart-1" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-oxygen">
          <h4>ìš©ì¡´ì‚°ì†Œ</h4>
          <div class="data-container">
            <canvas id="chart-2" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-temperature">
          <h4>ìˆ˜ì˜¨</h4>
          <div class="data-container">
            <canvas id="chart-3" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-salinity">
          <h4>ì—¼ë„</h4>
          <div class="data-container">
            <canvas id="chart-4" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-ammonia">
          <h4>ì•”ëª¨ë‹ˆì•„</h4>
          <div class="data-container">
            <canvas id="chart-5" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-nitrite">
          <h4>ì•„ì§ˆì‚°</h4>
          <div class="data-container">
            <canvas id="chart-6" width="200" height="200"></canvas>
          </div>
        </div>
      </section>

      <!-- ìˆ˜ì¡°ì •ë³´ì™€ ì‹¤ì‹œê°„ ê·¸ë˜í”„ -->
      <section class="dashboard-cards">
        <div class="tank-info">
          <h4>ìˆ˜ì¡°ì •ë³´</h4><br>
          <p><strong>ìˆ˜ì¡° ID:</strong> <span th:text="${selectedTank?.tankIdx ?: 'ì •ë³´ ì—†ìŒ'}"></span></p>
          <p><strong>ì§ê²½:</strong> <span th:text="${selectedTank?.tankWidth ?: 'ì •ë³´ ì—†ìŒ'}"></span> m</p>
          <p><strong>ë†’ì´:</strong> <span th:text="${selectedTank?.tankHeight ?: 'ì •ë³´ ì—†ìŒ'}"></span> m</p>
          <p><strong>ìœ„ì¹˜:</strong> <span th:text="${selectedTank?.tankLocation ?: 'ì •ë³´ ì—†ìŒ'}"></span></p>
          <p><strong>í’ˆì¢…:</strong> <span th:text="${selectedTank?.fishType ?: 'ì •ë³´ ì—†ìŒ'}"></span></p>
          <p><strong>ì‚¬ìœ¡ ê°œì‹œì¼:</strong><span th:text="${selectedTank?.startedAt != null ? #temporals.format(selectedTank.startedAt, 'yyyy-MM-dd') : 'ì •ë³´ ì—†ìŒ'}"></span></p>
          <canvas id="tank-data"></canvas>
        </div>
        <div class="card card-graph">
          <div class="graph-container">
            <canvas id="aihubGraph"></canvas>
          </div>
        </div>
      </section>
    </main>

    <script>
      

      // ë¡œê·¸ì•„ì›ƒ í•¨ìˆ˜
       // ë¡œê·¸ì•„ì›ƒ í•¨ìˆ˜
      function handleLogout() {
        console.log("ğŸš€ ë¡œê·¸ì•„ì›ƒ ìš”ì²­");
        const authToken = localStorage.getItem("authToken");
        fetch("/api/member/logout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: authToken }),
        })
        .then(response => {
          if (response.ok) {
            console.log("âœ… ì„œë²„ ë¡œê·¸ì•„ì›ƒ ì„±ê³µ");
            localStorage.removeItem("authToken");
            localStorage.removeItem("autoLogin");
            localStorage.removeItem("savedUserId");
            localStorage.removeItem("savedPassword");
            sessionStorage.clear();
            document.cookie = "JSESSIONID=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            console.log("âœ… ëª¨ë“  ì €ì¥ì†Œ ë°ì´í„° ì‚­ì œ ì™„ë£Œ");
            setTimeout(() => {
              alert("âœ… ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ!");
              window.location.href = "/login";
            }, 1000*60*60*24);
          } else {
            console.warn("ğŸš¨ ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨: ì‘ë‹µ ì˜¤ë¥˜");
          }
        })
        .catch(error => console.error("ğŸš¨ ë¡œê·¸ì•„ì›ƒ ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error));
      }

      // DOMContentLoaded ì´ë²¤íŠ¸
      document.addEventListener("DOMContentLoaded", function () {
        // ì‚¬ì´ë“œë°” í† ê¸€
        document.getElementById("hamburgerBtn").addEventListener("click", () => {
          document.getElementById("sidebar").classList.toggle("active");
        });

        // ì„œë¸Œ ë©”ë‰´ í† ê¸€
        const toggleMenus = document.querySelectorAll(".toggle-menu");
        toggleMenus.forEach(menu => {
          menu.addEventListener("click", (e) => {
            const subMenu = menu.nextElementSibling;
            if (subMenu && subMenu.classList.contains("sub-menu")) {
              e.preventDefault();
              subMenu.style.display = subMenu.style.display === "block" ? "none" : "block";
            }
          });
        });

     // ì „ì—­ ë³€ìˆ˜ ì •ì˜
        const dataRanges = {
          'chart-1': { min: 7.3, max: 9.2, label: 'pH' },
          'chart-2': { min: 5.0, max: 15.0, label: 'Oâ‚‚ (mg/L)' },
          'chart-3': { min: 24.77, max: 31.0, label: 'Â°C' },
          'chart-4': { min: 0.5, max: 47.0 , label: 'ppt' },
          'chart-5': { min: 0.0, max: 0.5, label: 'NHâ‚ƒ (mg/L)' },
          'chart-6': { min: 0.0, max: 5.2, label: 'NOâ‚‚ (mg/L)' },
        };
		
     
     
        let gaugeValues = {
          'chart-1': null,
          'chart-2': null,
          'chart-3': null,
          'chart-4': null,
          'chart-5': null,
          'chart-6': null,
        };

        let realtimeChart = null;
        // ê²Œì´ì§€ ê´€ë ¨ ë³€ìˆ˜ ì •ì˜
        const canvasElements = [
          document.getElementById('chart-1'),
          document.getElementById('chart-2'),
          document.getElementById('chart-3'),
          document.getElementById('chart-4'),
          document.getElementById('chart-5'),
          document.getElementById('chart-6'),
        ];

        const angles = {
          'chart-1': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-2': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-3': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-4': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-5': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-6': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        };

        const animationStates = {
          'chart-1': { animating: false },
          'chart-2': { animating: false },
          'chart-3': { animating: false },
          'chart-4': { animating: false },
          'chart-5': { animating: false },
          'chart-6': { animating: false },
        };

        const ranges = [
        	  // ì‚°ì„±ë„ (pH)
        	  {
        	    warning1Min: 7.3,   warning1Max: 7.4,   // ê²½ê³ : 7.3 ~ 7.4 (ë‚®ìŒ)
        	    normalMin: 7.5,     normalMax: 9.0,     // ì •ìƒ: 7.5 ~ 9.0
        	    warning2Min: 9.1,   warning2Max: 9.2,   // ê²½ê³ : 9.1 ~ 9.2 (ë†’ìŒ)
        	    min: 7.3, max: 9.2   // ì •ê·œí™” ë²”ìœ„
        	  },
        	  // ìš©ì¡´ì‚°ì†Œ (mg/L)
        	  {
        	    warning1Min: null,  warning1Max: null,  // ë‚®ìŒ ê²½ê³  ì—†ìŒ (ì œê±°)
        	    normalMin: 5.0,     normalMax: 10.0,    // ì •ìƒ: 5.0 ~ 10.0
        	    warning2Min: 10.1,  warning2Max: 15.0,  // ê²½ê³ : 10.1 ~ 15.0 (ë†’ìŒ)
        	    min: 5.0, max: 15.0  // ì •ê·œí™” ë²”ìœ„
        	  },
        	  // ìˆ˜ì˜¨ (Â°C)
        	  {
        	    warning1Min: 24.77, warning1Max: 26.0,  // ê²½ê³ : 24.77 ~ 26.0 (ë‚®ìŒ)
        	    normalMin: 26.0,    normalMax: 30.0,    // ì •ìƒ: 26.0 ~ 30.0
        	    warning2Min: 31.0,  warning2Max: 31.0,  // ê²½ê³ : 31.0 (ë†’ìŒ)
        	    min: 24.77, max: 31.0 // ì •ê·œí™” ë²”ìœ„
        	  },
        	  // ì—¼ë„ (ppt)
        	  {
        	    warning1Min: null,  warning1Max: null,  // ë‚®ìŒ ê²½ê³  ì—†ìŒ (ì œê±°)
        	    normalMin: 0.5,     normalMax: 45.0,    // ì •ìƒ: 0.5 ~ 45.0
        	    warning2Min: 46.0,  warning2Max: 47.0,  // ê²½ê³ : 46.0 ~ 47.0 (ë†’ìŒ)
        	    min: 0.5, max: 47.0  // ì •ê·œí™” ë²”ìœ„
        	  },
        	  // ì•”ëª¨ë‹ˆì•„ (ppm)
        	  {
        	    warning1Min: null,  warning1Max: null,  // ë‚®ìŒ ê²½ê³  ì—†ìŒ (ì œê±°)
        	    normalMin: 0.0,     normalMax: 0.16,    // ì •ìƒ: 0.0 ~ 0.16
        	    warning2Min: 0.3,   warning2Max: 0.5,   // ê²½ê³ : 0.3 ~ 0.5 (ë†’ìŒ)
        	    min: 0.0, max: 0.5   // ì •ê·œí™” ë²”ìœ„
        	  },
        	  // ì•„ì§ˆì‚° (ppm)
        	  {
        	    warning1Min: null,  warning1Max: null,  // ë‚®ìŒ ê²½ê³  ì—†ìŒ (ì œê±°)
        	    normalMin: 0.0,     normalMax: 5.0,     // ì •ìƒ: 0.0 ~ 5.0
        	    warning2Min: 5.1,   warning2Max: 5.2,   // ê²½ê³ : 5.1 ~ 5.2 (ë†’ìŒ)
        	    min: 0.0, max: 5.2   // ì •ê·œí™” ë²”ìœ„
        	  }
        	];

        const chartIndexMap = {
          'chart-1': 0, 'chart-2': 1, 'chart-3': 2, 'chart-4': 3, 'chart-5': 4, 'chart-6': 5
        };

        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }

        function updateGauge(chartId, value, min, max) {
            const rangeIndex = chartIndexMap[chartId];
            const range = ranges[rangeIndex];

            if (value === null || value === undefined || isNaN(value)) {
                value = (range.normalMin + range.normalMax) / 2;
                console.warn(`updateGauge: ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ - chartId: ${chartId}, ê¸°ë³¸ê°’ ${value}ìœ¼ë¡œ ì„¤ì •`);
            }

            gaugeValues[chartId] = value;
            const totalRange = range.max - range.min;
            const totalAngle = Math.PI;
            const startAngle = Math.PI;

            let targetAngle;
            if (value < range.normalMin) {
                // ë‚®ì€ ìœ„í—˜ êµ¬ê°„ (warning1)
                const warning1Range = range.normalMin - range.warning1Min;
                const warning1Angle = (value - range.warning1Min) / warning1Range * (totalAngle / 3);
                targetAngle = startAngle + warning1Angle;
            } else if (value > range.normalMax) {
                // ë†’ì€ ìœ„í—˜ êµ¬ê°„ (warning2)
                const warning2Range = range.warning2Max - range.normalMax;
                const warning2Angle = (value - range.normalMax) / warning2Range * (totalAngle / 3);
                targetAngle = startAngle + (2 * totalAngle / 3) + warning2Angle;
            } else {
                // ì •ìƒ êµ¬ê°„
                const normalRange = range.normalMax - range.normalMin;
                const normalAngle = (value - range.normalMin) / normalRange * (totalAngle / 3);
                targetAngle = startAngle + (totalAngle / 3) + normalAngle;
            }

            angles[chartId].target = targetAngle;
            
            if (!animationStates[chartId].animating) {
                animationStates[chartId].animating = true;
                animateGauge(chartId);
            }
        }


        function animateGauge(chartId) {
          const canvas = document.getElementById(chartId);
          const ctx = canvas.getContext("2d");
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          const startAngle = angles[chartId].current;
          const targetAngle = angles[chartId].target;
          const duration = 1000;
          let startTime = null;

          function step(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutQuad(progress);

            angles[chartId].current = startAngle + (targetAngle - startAngle) * easedProgress;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawGaugeOnCanvas(chartId, canvas);

            const centerX = canvasWidth / 2;
            const centerY = canvasHeight - 50;
            const len = 80;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angles[chartId].current) * len, centerY + Math.sin(angles[chartId].current) * len);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 4;
            ctx.stroke();

            const value = gaugeValues[chartId] ? gaugeValues[chartId].toFixed(3) : '-';
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const radius = 100;
            const textY = centerY - radius / 3;
            ctx.fillText(value, centerX, textY);

            if (progress < 1) {
              requestAnimationFrame(step);
            } else {
              animationStates[chartId].animating = false;
            }
          }

          requestAnimationFrame(step);
        }

        function drawGaugeOnCanvas(canvasId, canvas) {
          const ctx = canvas.getContext('2d');
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;
          const centerX = canvasWidth / 2;
          const centerY = canvasHeight - 50;
          const radius = 100;
          const gaugeWidth = 30;

          const colors = {
            warning1: ['#ff4500', '#ff7f7f'],
            normal: ['#32cd32', '#90ee90'],
            warning2: ['#ff4500', '#ff7f7f']
          };

          const labels = { warning1: 'ê²½ê³ ', normal: 'ì •ìƒ', warning2: 'ê²½ê³ ' };
          const rangeIndex = chartIndexMap[canvasId];
          const range = ranges[rangeIndex];

          function drawGauge() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            const totalAngle = Math.PI;
            const startAngle = Math.PI;
            const sectionAngle = totalAngle / 3;
            let currentAngle = startAngle;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
         // ì²« ë²ˆì§¸ êµ¬ê°„: í•­ìƒ ë¹¨ê°„ìƒ‰ (ë‚®ìŒ ê²½ê³ )
            drawSection(currentAngle, sectionAngle, colors.warning1);
            currentAngle += sectionAngle;

            // ë‘ ë²ˆì§¸ êµ¬ê°„: í•­ìƒ ì´ˆë¡ìƒ‰ (ì •ìƒ)
            drawSection(currentAngle, sectionAngle, colors.normal);
            currentAngle += sectionAngle;

            // ì„¸ ë²ˆì§¸ êµ¬ê°„: í•­ìƒ ë¹¨ê°„ìƒ‰ (ë†’ìŒ ê²½ê³ )
            drawSection(currentAngle, sectionAngle, colors.warning2);

            ctx.shadowBlur = 0;
            drawLabels(startAngle, sectionAngle);
          }

          function drawSection(start, angle, colorPair) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, start, start + angle);
            ctx.arc(centerX, centerY, radius - gaugeWidth, start + angle, start, true);
            ctx.closePath();
            ctx.fillStyle = colorPair[0];
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
          }

          function drawLabels(startAngle, sectionAngle) {
            const labelRadius = radius - gaugeWidth / 2;
            ctx.fillStyle = '#000';
            ctx.font = 'bold 15px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const angles = [
              startAngle + sectionAngle / 2,
              startAngle + sectionAngle + sectionAngle / 2,
              startAngle + sectionAngle * 2 + sectionAngle / 2
            ];
            const texts = [labels.warning1, labels.normal, labels.warning2];

            angles.forEach((angle, i) => {
              const x = centerX + Math.cos(angle) * labelRadius;
              const y = centerY + Math.sin(angle) * labelRadius;
              ctx.fillText(texts[i], x, y);
            });
          }

          drawGauge();
        }

        // ì´ˆê¸° ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
        canvasElements.forEach(canvas => {
          drawGaugeOnCanvas(canvas.id, canvas);
        });

        // ìµœì‹  ìˆ˜ì¡° ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
        function fetchLatestTankData() {
          const urlParams = new URLSearchParams(window.location.search);
          const tankIdx = urlParams.get("tankIdx");

          if (tankIdx) {
            fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
              .then(response => {
                if (!response.ok) throw new Error(`HTTP ì˜¤ë¥˜: ${response.status}`);
                return response.json();
              })
              .then(data => {
                console.log("âœ… ìµœì‹  ìˆ˜ì¡° ë°ì´í„° ë¡œë“œ ì™„ë£Œ:", data);
                updateGauge('chart-1', parseFloat(data.waterPh), ranges[0].min, ranges[0].max);
                updateGauge('chart-2', parseFloat(data.waterDo), ranges[1].min, ranges[1].max);
                updateGauge('chart-3', parseFloat(data.waterTemp), ranges[2].min, ranges[2].max);
                updateGauge('chart-4', parseFloat(data.waterSalt), ranges[3].min, ranges[3].max);
                updateGauge('chart-5', parseFloat(data.waterAmmonia), ranges[4].min, ranges[4].max);
                updateGauge('chart-6', parseFloat(data.waterNitrogen), ranges[5].min, ranges[5].max);
              })
              .catch(error => console.error("âŒ ìˆ˜ì¡° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error));
          } else {
            console.warn("tankIdxê°€ URLì— ì—†ìŠµë‹ˆë‹¤.");
          }
        }

        // ì´ˆê¸° ë°ì´í„° ë¡œë“œ ë° ì£¼ê¸°ì  ê°±ì‹ 
        fetchLatestTankData();
        setInterval(fetchLatestTankData, 1000);

        // í´ë¦­ ì´ë²¤íŠ¸ ë° ì‹¤ì‹œê°„ ë°ì´í„°
        const cardElements = document.querySelectorAll('.card');
        let labelsMap = {};
        let valuesMap = {};

        cardElements.forEach(card => {
          const canvas = card.querySelector('canvas');
          const chartId = canvas.id;
          labelsMap[chartId] = [];
          valuesMap[chartId] = [];

          card.addEventListener('click', () => {
            cardElements.forEach(c => c.classList.remove('clicked', 'animate-click'));
            card.classList.add('clicked', 'animate-click');
            setTimeout(() => card.classList.remove('animate-click'), 300);
            const label = dataRanges[chartId].label;
            showGraphFor(chartId, label);
          });
        });

        // ì´ˆê¸° ë¹ˆ ê·¸ë˜í”„ ì„¤ì •
        const ctx = document.getElementById('aihubGraph').getContext('2d');
        realtimeChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [{
              label: 'ë°ì´í„° ì—†ìŒ',
              data: [],
              borderColor: '#4A90E2',
              backgroundColor: 'rgba(74, 144, 226, 0.2)',
              fill: true,
              tension: 0.3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: 'ì‹¤ì‹œê°„ ë°ì´í„°', color: '#ffffff', font: { size: 14 } }, ticks: { color: '#ffffff', font: { size: 12 } } },
              y: { ticks: { color: '#ffffff', font: { size: 12 }, padding: 10 } }
            },
            plugins: {
              legend: { display: false },
              title: { display: true, color: '#ffffff', font: { size: 16 }, padding: { top: 10, bottom: 20 } }
            }
          }
        });

        function showGraphFor(chartId, label) {
          const ctx = document.getElementById('aihubGraph').getContext('2d');
          const valueKeyMap = {
            'chart-1': 'waterPh', 'chart-2': 'waterDo', 'chart-3': 'waterTemp',
            'chart-4': 'waterSalt', 'chart-5': 'waterAmmonia', 'chart-6': 'waterNitrogen'
          };
          const dataKey = valueKeyMap[chartId];

          if (realtimeChart) realtimeChart.destroy();

          realtimeChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labelsMap[chartId],
              datasets: [{
                label: `${label} ì‹¤ì‹œê°„ ë°ì´í„°`,
                data: valuesMap[chartId],
                borderColor: '#4A90E2',
                backgroundColor: 'rgba(74, 144, 226, 0.2)',
                fill: true,
                tension: 0.3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: { title: { display: true, text: 'ì‹¤ì‹œê°„ ë°ì´í„°', color: '#ffffff', font: { size: 14 } }, ticks: { color: '#ffffff', font: { size: 12 } } },
                y: { ticks: { color: '#ffffff', font: { size: 12 } } }
              },
              plugins: {
                legend: { display: false },
                title: { display: true, text: label, color: '#ffffff', font: { size: 16 }, padding: { top: 10, bottom: 20 } }
              }
            }
          });

          fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);
          if (window.graphInterval) clearInterval(window.graphInterval);
          window.graphInterval = setInterval(() => {
            fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);
          }, 1000);
        }

        function fetchLatestTankDataForGraph(chartId, dataKey, labels, values, chart) {
          const urlParams = new URLSearchParams(window.location.search);
          const tankIdx = urlParams.get("tankIdx");

          if (tankIdx) {
            fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
              .then(response => response.json())
              .then(data => {
                const value = parseFloat(data[dataKey]);
                const now = new Date();
                const timeLabel = now.toLocaleTimeString();

                if (!isNaN(value)) {
                  labels.push(timeLabel);
                  values.push(value);

                  if (labels.length > 10) {
                    labels.shift();
                    values.shift();
                  }

                  chart.data.labels = labels;
                  chart.data.datasets[0].data = values;
                  chart.update();
                }
              })
              .catch(err => console.error("âŒ ê·¸ë˜í”„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", err));
          }
        }
      });
    </script>
  </body>
</html>