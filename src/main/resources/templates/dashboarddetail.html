<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="새우양식 관제시스템 대시보드" />
    <link rel="stylesheet" href="/css/dashboarddetail.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <title>관제센터 대시보드</title>
  </head>
  <body>
    <!-- 햄버거 버튼 -->
    <button class="hamburger-btn" id="hamburgerBtn">☰</button>

    <!-- 사이드바 -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>메뉴</h2>
      </div>
      <ul class="sidebar-menu">
        <li><a href="/maindashboard" class="toggle-menu">홈</a></li>
        <li><a href="/tank" class="toggle-menu">수조 정보 등록</a></li>
        <li><a href="/alarmHistory2" class="toggle-menu">알람 히스토리</a></li>
        <li>
          <a href="javascript:void(0)" class="toggle-menu">회원 정보 관리</a>
          <ul class="sub-menu">
            <li><a th:href="@{/edit/{id}(id=${session.loginUser.userId})}">회원 정보 수정</a></li>
            <li><a href="/delete">회원 탈퇴</a></li>
          </ul>
        </li>
      </ul>
    </div>

    <!-- 메인 콘텐츠 -->
    <main class="main-content">
      <header class="header">
        <h1 class="page-title">세부관제시스템</h1>
        <div class="user-info">
          <div th:if="${session.loginUser != null}">
            <p th:text="${session.loginUser.userId}"></p>
          </div>
          <button class="logout-btn" onclick="handleLogout()">로그아웃</button>
        </div>
      </header>

      <!-- 데이터 카드 -->
      <section class="dashboard-cards">
        <div class="card card-ph">
          <h4>산성도</h4>
          <div class="data-container">
            <canvas id="chart-1" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-oxygen">
          <h4>용존산소</h4>
          <div class="data-container">
            <canvas id="chart-2" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-temperature">
          <h4>수온</h4>
          <div class="data-container">
            <canvas id="chart-3" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-salinity">
          <h4>염도</h4>
          <div class="data-container">
            <canvas id="chart-4" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-ammonia">
          <h4>암모니아</h4>
          <div class="data-container">
            <canvas id="chart-5" width="200" height="200"></canvas>
          </div>
        </div>
        <div class="card card-nitrite">
          <h4>아질산</h4>
          <div class="data-container">
            <canvas id="chart-6" width="200" height="200"></canvas>
          </div>
        </div>
      </section>

      <!-- 수조정보와 실시간 그래프 -->
      <section class="dashboard-cards">
        <div class="tank-info">
          <h4>수조정보</h4><br>
          <p><strong>수조 ID:</strong> <span th:text="${selectedTank?.tankIdx ?: '정보 없음'}"></span></p>
          <p><strong>직경:</strong> <span th:text="${selectedTank?.tankWidth ?: '정보 없음'}"></span> m</p>
          <p><strong>높이:</strong> <span th:text="${selectedTank?.tankHeight ?: '정보 없음'}"></span> m</p>
          <p><strong>위치:</strong> <span th:text="${selectedTank?.tankLocation ?: '정보 없음'}"></span></p>
          <p><strong>품종:</strong> <span th:text="${selectedTank?.fishType ?: '정보 없음'}"></span></p>
          <p><strong>사육 개시일:</strong><span th:text="${selectedTank?.startedAt != null ? #temporals.format(selectedTank.startedAt, 'yyyy-MM-dd') : '정보 없음'}"></span></p>
          <canvas id="tank-data"></canvas>
        </div>
        <div class="card card-graph">
          <div class="graph-container">
            <canvas id="aihubGraph"></canvas>
          </div>
        </div>
      </section>
    </main>

    <script>
      

      // 로그아웃 함수
       // 로그아웃 함수
      function handleLogout() {
        console.log("🚀 로그아웃 요청");
        const authToken = localStorage.getItem("authToken");
        fetch("/api/member/logout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ token: authToken }),
        })
        .then(response => {
          if (response.ok) {
            console.log("✅ 서버 로그아웃 성공");
            localStorage.removeItem("authToken");
            localStorage.removeItem("autoLogin");
            localStorage.removeItem("savedUserId");
            localStorage.removeItem("savedPassword");
            sessionStorage.clear();
            document.cookie = "JSESSIONID=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            console.log("✅ 모든 저장소 데이터 삭제 완료");
            setTimeout(() => {
              alert("✅ 로그아웃 완료!");
              window.location.href = "/login";
            }, 1000*60*60*24);
          } else {
            console.warn("🚨 로그아웃 실패: 응답 오류");
          }
        })
        .catch(error => console.error("🚨 로그아웃 요청 중 오류 발생:", error));
      }

      // DOMContentLoaded 이벤트
      document.addEventListener("DOMContentLoaded", function () {
        // 사이드바 토글
        document.getElementById("hamburgerBtn").addEventListener("click", () => {
          document.getElementById("sidebar").classList.toggle("active");
        });

        // 서브 메뉴 토글
        const toggleMenus = document.querySelectorAll(".toggle-menu");
        toggleMenus.forEach(menu => {
          menu.addEventListener("click", (e) => {
            const subMenu = menu.nextElementSibling;
            if (subMenu && subMenu.classList.contains("sub-menu")) {
              e.preventDefault();
              subMenu.style.display = subMenu.style.display === "block" ? "none" : "block";
            }
          });
        });

     // 전역 변수 정의
        const dataRanges = {
          'chart-1': { min: 7.3, max: 9.2, label: 'pH' },
          'chart-2': { min: 5.0, max: 15.0, label: 'O₂ (mg/L)' },
          'chart-3': { min: 24.77, max: 31.0, label: '°C' },
          'chart-4': { min: 0.5, max: 47.0 , label: 'ppt' },
          'chart-5': { min: 0.0, max: 0.5, label: 'NH₃ (mg/L)' },
          'chart-6': { min: 0.0, max: 5.2, label: 'NO₂ (mg/L)' },
        };
		
     
     
        let gaugeValues = {
          'chart-1': null,
          'chart-2': null,
          'chart-3': null,
          'chart-4': null,
          'chart-5': null,
          'chart-6': null,
        };

        let realtimeChart = null;
        // 게이지 관련 변수 정의
        const canvasElements = [
          document.getElementById('chart-1'),
          document.getElementById('chart-2'),
          document.getElementById('chart-3'),
          document.getElementById('chart-4'),
          document.getElementById('chart-5'),
          document.getElementById('chart-6'),
        ];

        const angles = {
          'chart-1': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-2': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-3': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-4': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-5': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
          'chart-6': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        };

        const animationStates = {
          'chart-1': { animating: false },
          'chart-2': { animating: false },
          'chart-3': { animating: false },
          'chart-4': { animating: false },
          'chart-5': { animating: false },
          'chart-6': { animating: false },
        };

        const ranges = [
        	  // 산성도 (pH)
        	  {
        	    warning1Min: 7.3,   warning1Max: 7.4,   // 경고: 7.3 ~ 7.4 (낮음)
        	    normalMin: 7.5,     normalMax: 9.0,     // 정상: 7.5 ~ 9.0
        	    warning2Min: 9.1,   warning2Max: 9.2,   // 경고: 9.1 ~ 9.2 (높음)
        	    min: 7.3, max: 9.2   // 정규화 범위
        	  },
        	  // 용존산소 (mg/L)
        	  {
        	    warning1Min: null,  warning1Max: null,  // 낮음 경고 없음 (제거)
        	    normalMin: 5.0,     normalMax: 10.0,    // 정상: 5.0 ~ 10.0
        	    warning2Min: 10.1,  warning2Max: 15.0,  // 경고: 10.1 ~ 15.0 (높음)
        	    min: 5.0, max: 15.0  // 정규화 범위
        	  },
        	  // 수온 (°C)
        	  {
        	    warning1Min: 24.77, warning1Max: 26.0,  // 경고: 24.77 ~ 26.0 (낮음)
        	    normalMin: 26.0,    normalMax: 30.0,    // 정상: 26.0 ~ 30.0
        	    warning2Min: 31.0,  warning2Max: 31.0,  // 경고: 31.0 (높음)
        	    min: 24.77, max: 31.0 // 정규화 범위
        	  },
        	  // 염도 (ppt)
        	  {
        	    warning1Min: null,  warning1Max: null,  // 낮음 경고 없음 (제거)
        	    normalMin: 0.5,     normalMax: 45.0,    // 정상: 0.5 ~ 45.0
        	    warning2Min: 46.0,  warning2Max: 47.0,  // 경고: 46.0 ~ 47.0 (높음)
        	    min: 0.5, max: 47.0  // 정규화 범위
        	  },
        	  // 암모니아 (ppm)
        	  {
        	    warning1Min: null,  warning1Max: null,  // 낮음 경고 없음 (제거)
        	    normalMin: 0.0,     normalMax: 0.16,    // 정상: 0.0 ~ 0.16
        	    warning2Min: 0.3,   warning2Max: 0.5,   // 경고: 0.3 ~ 0.5 (높음)
        	    min: 0.0, max: 0.5   // 정규화 범위
        	  },
        	  // 아질산 (ppm)
        	  {
        	    warning1Min: null,  warning1Max: null,  // 낮음 경고 없음 (제거)
        	    normalMin: 0.0,     normalMax: 5.0,     // 정상: 0.0 ~ 5.0
        	    warning2Min: 5.1,   warning2Max: 5.2,   // 경고: 5.1 ~ 5.2 (높음)
        	    min: 0.0, max: 5.2   // 정규화 범위
        	  }
        	];

        const chartIndexMap = {
          'chart-1': 0, 'chart-2': 1, 'chart-3': 2, 'chart-4': 3, 'chart-5': 4, 'chart-6': 5
        };

        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }

        function updateGauge(chartId, value, min, max) {
            const rangeIndex = chartIndexMap[chartId];
            const range = ranges[rangeIndex];

            if (value === null || value === undefined || isNaN(value)) {
                value = (range.normalMin + range.normalMax) / 2;
                console.warn(`updateGauge: 유효하지 않은 값 - chartId: ${chartId}, 기본값 ${value}으로 설정`);
            }

            gaugeValues[chartId] = value;
            const totalRange = range.max - range.min;
            const totalAngle = Math.PI;
            const startAngle = Math.PI;

            let targetAngle;
            if (value < range.normalMin) {
                // 낮은 위험 구간 (warning1)
                const warning1Range = range.normalMin - range.warning1Min;
                const warning1Angle = (value - range.warning1Min) / warning1Range * (totalAngle / 3);
                targetAngle = startAngle + warning1Angle;
            } else if (value > range.normalMax) {
                // 높은 위험 구간 (warning2)
                const warning2Range = range.warning2Max - range.normalMax;
                const warning2Angle = (value - range.normalMax) / warning2Range * (totalAngle / 3);
                targetAngle = startAngle + (2 * totalAngle / 3) + warning2Angle;
            } else {
                // 정상 구간
                const normalRange = range.normalMax - range.normalMin;
                const normalAngle = (value - range.normalMin) / normalRange * (totalAngle / 3);
                targetAngle = startAngle + (totalAngle / 3) + normalAngle;
            }

            angles[chartId].target = targetAngle;
            
            if (!animationStates[chartId].animating) {
                animationStates[chartId].animating = true;
                animateGauge(chartId);
            }
        }


        function animateGauge(chartId) {
          const canvas = document.getElementById(chartId);
          const ctx = canvas.getContext("2d");
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          const startAngle = angles[chartId].current;
          const targetAngle = angles[chartId].target;
          const duration = 1000;
          let startTime = null;

          function step(timestamp) {
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeOutQuad(progress);

            angles[chartId].current = startAngle + (targetAngle - startAngle) * easedProgress;

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            drawGaugeOnCanvas(chartId, canvas);

            const centerX = canvasWidth / 2;
            const centerY = canvasHeight - 50;
            const len = 80;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angles[chartId].current) * len, centerY + Math.sin(angles[chartId].current) * len);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 4;
            ctx.stroke();

            const value = gaugeValues[chartId] ? gaugeValues[chartId].toFixed(3) : '-';
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const radius = 100;
            const textY = centerY - radius / 3;
            ctx.fillText(value, centerX, textY);

            if (progress < 1) {
              requestAnimationFrame(step);
            } else {
              animationStates[chartId].animating = false;
            }
          }

          requestAnimationFrame(step);
        }

        function drawGaugeOnCanvas(canvasId, canvas) {
          const ctx = canvas.getContext('2d');
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;
          const centerX = canvasWidth / 2;
          const centerY = canvasHeight - 50;
          const radius = 100;
          const gaugeWidth = 30;

          const colors = {
            warning1: ['#ff4500', '#ff7f7f'],
            normal: ['#32cd32', '#90ee90'],
            warning2: ['#ff4500', '#ff7f7f']
          };

          const labels = { warning1: '경고', normal: '정상', warning2: '경고' };
          const rangeIndex = chartIndexMap[canvasId];
          const range = ranges[rangeIndex];

          function drawGauge() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            const totalAngle = Math.PI;
            const startAngle = Math.PI;
            const sectionAngle = totalAngle / 3;
            let currentAngle = startAngle;

            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;
         // 첫 번째 구간: 항상 빨간색 (낮음 경고)
            drawSection(currentAngle, sectionAngle, colors.warning1);
            currentAngle += sectionAngle;

            // 두 번째 구간: 항상 초록색 (정상)
            drawSection(currentAngle, sectionAngle, colors.normal);
            currentAngle += sectionAngle;

            // 세 번째 구간: 항상 빨간색 (높음 경고)
            drawSection(currentAngle, sectionAngle, colors.warning2);

            ctx.shadowBlur = 0;
            drawLabels(startAngle, sectionAngle);
          }

          function drawSection(start, angle, colorPair) {
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, start, start + angle);
            ctx.arc(centerX, centerY, radius - gaugeWidth, start + angle, start, true);
            ctx.closePath();
            ctx.fillStyle = colorPair[0];
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
          }

          function drawLabels(startAngle, sectionAngle) {
            const labelRadius = radius - gaugeWidth / 2;
            ctx.fillStyle = '#000';
            ctx.font = 'bold 15px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const angles = [
              startAngle + sectionAngle / 2,
              startAngle + sectionAngle + sectionAngle / 2,
              startAngle + sectionAngle * 2 + sectionAngle / 2
            ];
            const texts = [labels.warning1, labels.normal, labels.warning2];

            angles.forEach((angle, i) => {
              const x = centerX + Math.cos(angle) * labelRadius;
              const y = centerY + Math.sin(angle) * labelRadius;
              ctx.fillText(texts[i], x, y);
            });
          }

          drawGauge();
        }

        // 초기 캔버스 그리기
        canvasElements.forEach(canvas => {
          drawGaugeOnCanvas(canvas.id, canvas);
        });

        // 최신 수조 데이터 가져오기
        function fetchLatestTankData() {
          const urlParams = new URLSearchParams(window.location.search);
          const tankIdx = urlParams.get("tankIdx");

          if (tankIdx) {
            fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
              .then(response => {
                if (!response.ok) throw new Error(`HTTP 오류: ${response.status}`);
                return response.json();
              })
              .then(data => {
                console.log("✅ 최신 수조 데이터 로드 완료:", data);
                updateGauge('chart-1', parseFloat(data.waterPh), ranges[0].min, ranges[0].max);
                updateGauge('chart-2', parseFloat(data.waterDo), ranges[1].min, ranges[1].max);
                updateGauge('chart-3', parseFloat(data.waterTemp), ranges[2].min, ranges[2].max);
                updateGauge('chart-4', parseFloat(data.waterSalt), ranges[3].min, ranges[3].max);
                updateGauge('chart-5', parseFloat(data.waterAmmonia), ranges[4].min, ranges[4].max);
                updateGauge('chart-6', parseFloat(data.waterNitrogen), ranges[5].min, ranges[5].max);
              })
              .catch(error => console.error("❌ 수조 데이터 로드 실패:", error));
          } else {
            console.warn("tankIdx가 URL에 없습니다.");
          }
        }

        // 초기 데이터 로드 및 주기적 갱신
        fetchLatestTankData();
        setInterval(fetchLatestTankData, 1000);

        // 클릭 이벤트 및 실시간 데이터
        const cardElements = document.querySelectorAll('.card');
        let labelsMap = {};
        let valuesMap = {};

        cardElements.forEach(card => {
          const canvas = card.querySelector('canvas');
          const chartId = canvas.id;
          labelsMap[chartId] = [];
          valuesMap[chartId] = [];

          card.addEventListener('click', () => {
            cardElements.forEach(c => c.classList.remove('clicked', 'animate-click'));
            card.classList.add('clicked', 'animate-click');
            setTimeout(() => card.classList.remove('animate-click'), 300);
            const label = dataRanges[chartId].label;
            showGraphFor(chartId, label);
          });
        });

        // 초기 빈 그래프 설정
        const ctx = document.getElementById('aihubGraph').getContext('2d');
        realtimeChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [{
              label: '데이터 없음',
              data: [],
              borderColor: '#4A90E2',
              backgroundColor: 'rgba(74, 144, 226, 0.2)',
              fill: true,
              tension: 0.3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { title: { display: true, text: '실시간 데이터', color: '#ffffff', font: { size: 14 } }, ticks: { color: '#ffffff', font: { size: 12 } } },
              y: { ticks: { color: '#ffffff', font: { size: 12 }, padding: 10 } }
            },
            plugins: {
              legend: { display: false },
              title: { display: true, color: '#ffffff', font: { size: 16 }, padding: { top: 10, bottom: 20 } }
            }
          }
        });

        function showGraphFor(chartId, label) {
          const ctx = document.getElementById('aihubGraph').getContext('2d');
          const valueKeyMap = {
            'chart-1': 'waterPh', 'chart-2': 'waterDo', 'chart-3': 'waterTemp',
            'chart-4': 'waterSalt', 'chart-5': 'waterAmmonia', 'chart-6': 'waterNitrogen'
          };
          const dataKey = valueKeyMap[chartId];

          if (realtimeChart) realtimeChart.destroy();

          realtimeChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labelsMap[chartId],
              datasets: [{
                label: `${label} 실시간 데이터`,
                data: valuesMap[chartId],
                borderColor: '#4A90E2',
                backgroundColor: 'rgba(74, 144, 226, 0.2)',
                fill: true,
                tension: 0.3
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: { title: { display: true, text: '실시간 데이터', color: '#ffffff', font: { size: 14 } }, ticks: { color: '#ffffff', font: { size: 12 } } },
                y: { ticks: { color: '#ffffff', font: { size: 12 } } }
              },
              plugins: {
                legend: { display: false },
                title: { display: true, text: label, color: '#ffffff', font: { size: 16 }, padding: { top: 10, bottom: 20 } }
              }
            }
          });

          fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);
          if (window.graphInterval) clearInterval(window.graphInterval);
          window.graphInterval = setInterval(() => {
            fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], realtimeChart);
          }, 1000);
        }

        function fetchLatestTankDataForGraph(chartId, dataKey, labels, values, chart) {
          const urlParams = new URLSearchParams(window.location.search);
          const tankIdx = urlParams.get("tankIdx");

          if (tankIdx) {
            fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
              .then(response => response.json())
              .then(data => {
                const value = parseFloat(data[dataKey]);
                const now = new Date();
                const timeLabel = now.toLocaleTimeString();

                if (!isNaN(value)) {
                  labels.push(timeLabel);
                  values.push(value);

                  if (labels.length > 10) {
                    labels.shift();
                    values.shift();
                  }

                  chart.data.labels = labels;
                  chart.data.datasets[0].data = values;
                  chart.update();
                }
              })
              .catch(err => console.error("❌ 그래프 데이터 로드 실패:", err));
          }
        }
      });
    </script>
  </body>
</html>