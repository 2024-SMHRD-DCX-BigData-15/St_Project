<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ìƒˆìš°ì–‘ì‹ ê´€ì œì‹œìŠ¤í…œ ëŒ€ì‹œë³´ë“œ" />
  <link rel="stylesheet" href="/css/dashboarddetail.css" />
  <!-- Flatpickr CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css" />
  <!-- Flatpickr JS -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <!-- Flatpickr í•œê¸€ ë¡œì¼€ì¼ -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ko.js"></script>
  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <title>ê´€ì œì„¼í„° ëŒ€ì‹œë³´ë“œ</title>
</head>
<body>
  <!-- í–„ë²„ê±° ë²„íŠ¼ -->
  <button class="hamburger-btn" id="hamburgerBtn">â˜°</button>

  <!-- ì‚¬ì´ë“œë°” -->
  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h2>ë©”ë‰´</h2>
    </div>
    <ul class="sidebar-menu">
      <li><a href="/maindashboard" class="toggle-menu">í™ˆ</a></li>
      <li><a href="/tank" class="toggle-menu">ìˆ˜ì¡° ì •ë³´ ë“±ë¡</a></li>
      <li><a href="/alarmHistory2" class="toggle-menu">ì•ŒëŒ íˆìŠ¤í† ë¦¬</a></li>
      <li>
        <a href="javascript:void(0)" class="toggle-menu">íšŒì› ì •ë³´ ê´€ë¦¬</a>
        <ul class="sub-menu">
          <li><a th:href="@{/edit/{id}(id=${session.loginUser.userId})}">íšŒì› ì •ë³´ ìˆ˜ì •</a></li>
          <li><a href="/delete">íšŒì› íƒˆí‡´</a></li>
        </ul>
      </li>
    </ul>
  </div>

  <!-- ë©”ì¸ ì½˜í…ì¸  -->
  <main class="main-content">
    <header class="header">
      <h1 class="page-title">ì„¸ë¶€ê´€ì œì‹œìŠ¤í…œ</h1>
      <div class="user-info">
        <div th:if="${session.loginUser != null}">
          <p th:text="${session.loginUser.userId}"></p>
        </div>
        <button class="logout-btn" onclick="handleLogout()">ë¡œê·¸ì•„ì›ƒ</button>
      </div>
    </header>

    <!-- ë°ì´í„° ì¹´ë“œ -->
    <section class="dashboard-cards" th:with="tankIdx=${param.tankIdx != null ? param.tankIdx : '1'}">
      <div class="card card-ph" th:id="'ph-item-' + ${tankIdx}">
        <h4>ì‚°ì„±ë„</h4>
        <div class="data-container">
          <canvas th:id="'chart-1'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'ph-' + ${tankIdx}">-</span>
        </div>
      </div>
      <div class="card card-oxygen" th:id="'do-item-' + ${tankIdx}">
        <h4>ìš©ì¡´ì‚°ì†Œ</h4>
        <div class="data-container">
          <canvas th:id="'chart-2'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'do-' + ${tankIdx}">-</span>
        </div>
      </div>
      <div class="card card-temperature" th:id="'temp-item-' + ${tankIdx}">
        <h4>ìˆ˜ì˜¨</h4>
        <div class="data-container">
          <canvas th:id="'chart-3'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'temp-' + ${tankIdx}">-</span>
        </div>
      </div>
      <div class="card card-salinity" th:id="'salt-item-' + ${tankIdx}">
        <h4>ì—¼ë„</h4>
        <div class="data-container">
          <canvas th:id="'chart-4'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'salt-' + ${tankIdx}">-</span>
        </div>
      </div>
      <div class="card card-ammonia" th:id="'ammonia-item-' + ${tankIdx}">
        <h4>ì•”ëª¨ë‹ˆì•„</h4>
        <div class="data-container">
          <canvas th:id="'chart-5'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'ammonia-' + ${tankIdx}">-</span>
        </div>
      </div>
      <div class="card card-nitrite" th:id="'nitrogen-item-' + ${tankIdx}">
        <h4>ì•„ì§ˆì‚°</h4>
        <div class="data-container">
          <canvas th:id="'chart-6'" width="200" height="200"></canvas>
        </div>
        <div class="data-value-container">
          <span class="data-value" th:id="'nitrogen-' + ${tankIdx}">-</span>
        </div>
      </div>
    </section>

    <!-- ìˆ˜ì¡°ì •ë³´ì™€ ì‹¤ì‹œê°„ ê·¸ë˜í”„ -->
    <section class="dashboard-cards">
      <div class="tank-info" id="tankInfo">
        <button id="toggleTankInfoBtn" class="toggle-btn">ë‹¬ë ¥ ë³´ê¸°</button>
        <div class="tank-details">
          <h3>ìˆ˜ì¡°ì •ë³´</h3>
          <p>ìˆ˜ì¡° ID: <span th:text="${param.tankIdx != null ? param.tankIdx : '1'}"></span></p>
          <p>ì „ì¥: 21.0 m</p>
          <p>í­: 12.0 m</p>
          <p>ìœ„ì¹˜: 1</p>
          <p>í’ˆì¢…: í°ë‹¤ë¦¬ìƒˆìš°</p>
          <p>ì‚¬ìœ¡ ê°œì‹œì¼: 2025-03-18</p>
        </div>
        <div id="calendar" style="display: none;"></div>
        <input type="text" id="calendarInput" style="display: none;" />
      </div>
      <div class="card card-graph">
        <div class="graph-container">
          <canvas id="aihubGraph"></canvas>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ë¡œê·¸ì•„ì›ƒ í•¨ìˆ˜
    function handleLogout() {
      console.log("ğŸš€ ë¡œê·¸ì•„ì›ƒ ìš”ì²­");
      const authToken = localStorage.getItem("authToken");
      fetch("/api/member/logout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token: authToken }),
      })
      .then(response => {
        if (response.ok) {
          console.log("âœ… ì„œë²„ ë¡œê·¸ì•„ì›ƒ ì„±ê³µ");
          localStorage.removeItem("authToken");
          localStorage.removeItem("autoLogin");
          localStorage.removeItem("savedUserId");
          localStorage.removeItem("savedPassword");
          sessionStorage.clear();
          document.cookie = "JSESSIONID=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
          console.log("âœ… ëª¨ë“  ì €ì¥ì†Œ ë°ì´í„° ì‚­ì œ ì™„ë£Œ");
          setTimeout(() => {
            alert("âœ… ë¡œê·¸ì•„ì›ƒ ì™„ë£Œ!");
            window.location.href = "/login";
          }, 1000);
        } else {
          console.warn("ğŸš¨ ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨: ì‘ë‹µ ì˜¤ë¥˜");
        }
      })
      .catch(error => console.error("ğŸš¨ ë¡œê·¸ì•„ì›ƒ ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error));
    }

    // DOMContentLoaded ì´ë²¤íŠ¸
    document.addEventListener("DOMContentLoaded", function () {
      // ì‚¬ì´ë“œë°” í† ê¸€
      document.getElementById("hamburgerBtn").addEventListener("click", () => {
        document.getElementById("sidebar").classList.toggle("active");
      });

      // ì„œë¸Œ ë©”ë‰´ í† ê¸€
      const toggleMenus = document.querySelectorAll(".toggle-menu");
      toggleMenus.forEach(menu => {
        menu.addEventListener("click", (e) => {
          const subMenu = menu.nextElementSibling;
          if (subMenu && subMenu.classList.contains("sub-menu")) {
            e.preventDefault();
            subMenu.style.display = subMenu.style.display === "block" ? "none" : "block";
          }
        });
      });

      // ì¶”ê°€ ë³€ìˆ˜ (ë‹¬ë ¥ ë° í‰ê·  ë°ì´í„°)
      let isCalendarMode = false;
      let selectedDateRange = null;
      let isAverageMode = false;
      let flatpickrInstance = null;
      let selectedChartId = null;
      let realtimeChart = null;
      let labelsMap = {};
      let valuesMap = {};
      let smoothedValuesMap = {}; // ìŠ¤ë¬´ë”©ëœ ê°’ì„ ì €ì¥
      let animationProgressMap = {}; // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ ìƒíƒœ ì €ì¥

      const tankInfo = document.getElementById("tankInfo");
      const tankDetails = document.querySelector(".tank-details");
      const calendar = document.getElementById("calendar");
      const toggleTankInfoBtn = document.getElementById("toggleTankInfoBtn");

      // ë¡œì»¬ ì‹œê°„ëŒ€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë‚ ì§œë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ í¬ë§·íŒ…í•˜ëŠ” í•¨ìˆ˜
      function formatDateToLocal(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }

      // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ (ë‹¬ë ¥ í† ê¸€)
      toggleTankInfoBtn.addEventListener("click", function() {
        if (!isCalendarMode) {
          // ë‹¬ë ¥ ëª¨ë“œë¡œ ì „í™˜
          tankDetails.style.display = "none";
          calendar.style.display = "block";
          flatpickrInstance = flatpickr("#calendarInput", {
            inline: true,
            mode: "range",
            dateFormat: "Y-m-d",
            locale: "ko",
            onChange: function(selectedDates, dateStr, instance) {
              if (selectedDates.length === 2) {
                let [startDate, endDate] = selectedDates;
                startDate = new Date(startDate);
                startDate.setHours(0, 0, 0, 0);
                endDate = new Date(endDate);
                endDate.setHours(0, 0, 0, 0);
                console.log("flatpickr ì„ íƒëœ ì‹œì‘ ë‚ ì§œ (ë¡œì»¬):", formatDateToLocal(startDate));
                console.log("flatpickr ì„ íƒëœ ì¢…ë£Œ ë‚ ì§œ (ë¡œì»¬):", formatDateToLocal(endDate));
                selectedDateRange = { start: startDate, end: endDate };
                fetchAllDataForRange(startDate, endDate);
              }
            },
            onDayCreate: function(dObj, dStr, fp, dayElem) {
              const currentMonth = fp.currentMonth;
              const currentYear = fp.currentYear;
              const dayMonth = dayElem.dateObj.getMonth();
              const dayYear = dayElem.dateObj.getFullYear();
              if (dayMonth !== currentMonth || dayYear !== currentYear) {
                dayElem.classList.add("hidden-day");
                dayElem.classList.add("flatpickr-disabled");
              }
            },
            onMonthChange: function(selectedDates, dateStr, instance) {
              instance.redraw();
            }
          });
          toggleTankInfoBtn.textContent = "ìˆ˜ì¡° ì •ë³´ ë³´ê¸°";

          // ì‹¤ì‹œê°„ ê·¸ë˜í”„ ì—…ë°ì´íŠ¸ ì¤‘ë‹¨
          if (window.graphInterval) {
            console.log("âœ… fetchLatestTankDataForGraphì˜ setInterval ì¤‘ë‹¨");
            cancelAnimationFrame(window.graphInterval);
            window.graphInterval = null;
          }
        } else {
          // ìˆ˜ì¡° ì •ë³´ ëª¨ë“œë¡œ ì „í™˜
          if (flatpickrInstance) {
            flatpickrInstance.destroy();
            flatpickrInstance = null;
          }
          tankDetails.style.display = "block";
          calendar.style.display = "none";
          toggleTankInfoBtn.textContent = "ë‹¬ë ¥ ë³´ê¸°";

          // ì‹¤ì‹œê°„ ê·¸ë˜í”„ ë³µì›
          if (!isAverageMode) {
            if (selectedChartId) {
              const label = dataRanges[selectedChartId].label;
              resumeRealtimeGraph(selectedChartId, label);
            } else {
              resetToRealtimeGraph();
            }
          }
        }
        isCalendarMode = !isCalendarMode;
      });

      // ë‚ ì§œ ë²”ìœ„ì— ëŒ€í•œ ì „ì²´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
      async function fetchAllDataForRange(startDate, endDate) {
        console.log(`ğŸš€ fetchAllDataForRange í˜¸ì¶œ - ì‹œì‘ ë‚ ì§œ: ${formatDateToLocal(startDate)}, ì¢…ë£Œ ë‚ ì§œ: ${formatDateToLocal(endDate)}`);

        if (!selectedChartId) {
          console.warn("âš ï¸ ì¹´ë“œë¥¼ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”. selectedChartIdê°€ nullì…ë‹ˆë‹¤.");
          displayNoCardSelectedMessage();
          return;
        }
        console.log(`âœ… ì„ íƒëœ ì¹´ë“œ ID: ${selectedChartId}`);

        const urlParams = new URLSearchParams(window.location.search);
        const tankIdx = urlParams.get("tankIdx") || "1";
        console.log(`âœ… tankIdx: ${tankIdx}`);

        try {
          const dates = [];
          let currentDate = new Date(startDate);
          currentDate.setHours(0, 0, 0, 0);
          const end = new Date(endDate);
          end.setHours(0, 0, 0, 0);

          while (currentDate <= end) {
            dates.push(formatDateToLocal(currentDate));
            currentDate.setDate(currentDate.getDate() + 1);
          }
          console.log(`âœ… ìƒì„±ëœ ë‚ ì§œ ëª©ë¡: ${dates}`);

          const dataPromises = dates.map(async (date) => {
            console.log(`ğŸ“¡ ${date} ë°ì´í„° ìš”ì²­ ì‹œì‘: /tank/data?tankIdx=${tankIdx}&date=${date}`);
            const response = await fetch(`/tank/data?tankIdx=${tankIdx}&date=${date}`);
            if (!response.ok) {
              console.error(`âŒ ${date} ë°ì´í„° ìš”ì²­ ì‹¤íŒ¨ - HTTP ìƒíƒœ: ${response.status}`);
              throw new Error(`HTTP ì˜¤ë¥˜: ${response.status}`);
            }
            const jsonData = await response.json();
            const formattedData = jsonData.map(item => ({
              ...item,
              timestamp: item.recordDate ? item.recordDate.split('T')[1]?.split('.')[0] : '',
              ph: item.waterPh ?? 0,
              do: item.waterDo ?? 0,
              temp: item.waterTemp ?? 0,
              salt: item.waterSalt ?? 0,
              ammonia: item.waterAmmonia ?? 0,
              nitrogen: item.waterNitrogen ?? 0,
              fullTimestamp: item.recordDate
            }));
            console.log(`âœ… ${date} ë°ì´í„° ìš”ì²­ ì„±ê³µ:`, formattedData);
            return { date, data: formattedData };
          });

          const allData = await Promise.all(dataPromises);
          console.log("âœ… ë‚ ì§œ ë²”ìœ„ ì „ì²´ ë°ì´í„° ë¡œë“œ ì™„ë£Œ:", allData);

          if (allData.length === 0 || allData.every(item => !item.data || item.data.length === 0)) {
            console.warn("âš ï¸ ë°ì´í„°ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. allData:", allData);
            displayNoDataMessage();
            return;
          }

          const filteredData = filterDataByHour(allData);
          console.log("âœ… 1ì‹œê°„ ê°„ê²©ìœ¼ë¡œ í•„í„°ë§ëœ ë°ì´í„°:", filteredData);

          console.log(`ğŸ“Š ë°ì´í„° í‘œì‹œ ì‹œì‘ - chartId: ${selectedChartId}`);
          displayAllData(filteredData, selectedChartId);
          isAverageMode = false;
          console.log("âœ… fetchAllDataForRange ì™„ë£Œ");

        } catch (error) {
          console.error("âŒ ì „ì²´ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
          displayNoDataMessage();
        }
      }

      // 1ì‹œê°„ ê°„ê²©ìœ¼ë¡œ ë°ì´í„° í•„í„°ë§í•˜ëŠ” í•¨ìˆ˜
      function filterDataByHour(dataArray) {
        const filtered = [];
        const groupedByHour = {};

        dataArray.forEach(item => {
          if (item.data && item.data.length > 0) {
            item.data.forEach(entry => {
              if (!entry.fullTimestamp) return;
              const dateTime = new Date(entry.fullTimestamp);
              const dateKey = item.date;
              const hour = dateTime.getHours();
              const hourKey = `${dateKey} ${hour}:00`;

              if (!groupedByHour[hourKey]) {
                groupedByHour[hourKey] = [];
              }
              groupedByHour[hourKey].push(entry);
            });
          }
        });

        for (const hourKey in groupedByHour) {
          const entries = groupedByHour[hourKey];
          if (entries.length > 0) {
            const firstEntry = entries[0];
            filtered.push({
              date: hourKey.split(' ')[0],
              data: [{
                ...firstEntry,
                timestamp: hourKey.split(' ')[1]
              }]
            });
          }
        }

        filtered.sort((a, b) => {
          const dateA = new Date(`${a.date}T${a.data[0].timestamp}`);
          const dateB = new Date(`${b.date}T${b.data[0].timestamp}`);
          return dateA - dateB;
        });

        return filtered;
      }

      // ë°ì´í„°ê°€ ì—†ì„ ë•Œ ë©”ì‹œì§€ í‘œì‹œ
      function displayNoDataMessage() {
        const ctx = document.getElementById("aihubGraph").getContext("2d");
        if (realtimeChart) realtimeChart.destroy();

        const dateRangeText = selectedDateRange
          ? `${formatDateToLocal(selectedDateRange.start)} ~ ${formatDateToLocal(selectedDateRange.end)}`
          : "ì„ íƒëœ ë‚ ì§œ";

        realtimeChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: []
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: `ì „ì²´ ë°ì´í„° (${dateRangeText}) - ë°ì´í„° ì—†ìŒ`,
                color: "#ffffff",
                font: { size: 16 },
                padding: { top: 10, bottom: 20 }
              }
            },
            scales: {
              x: { display: false },
              y: { display: false }
            }
          }
        });
        isAverageMode = true;
      }

      // ì¹´ë“œê°€ ì„ íƒë˜ì§€ ì•Šì•˜ì„ ë•Œ ë©”ì‹œì§€ í‘œì‹œ
      function displayNoCardSelectedMessage() {
        const ctx = document.getElementById("aihubGraph").getContext("2d");
        if (realtimeChart) realtimeChart.destroy();

        realtimeChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: []
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              title: {
                display: true,
                text: "ì¹´ë“œë¥¼ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”",
                color: "#ffffff",
                font: { size: 16 },
                padding: { top: 10, bottom: 20 }
              }
            },
            scales: {
              x: { display: false },
              y: { display: false }
            }
          }
        });
        isAverageMode = true;
      }

      // ì „ì²´ ë°ì´í„° í‘œì‹œ (êº¾ì€ì„  ê·¸ë˜í”„ë¡œ ë³€ê²½)
      function displayAllData(dataArray, chartId) {
        const ctx = document.getElementById("aihubGraph").getContext("2d");
        if (realtimeChart) {
          console.log("âœ… ê¸°ì¡´ realtimeChart ì œê±°");
          realtimeChart.destroy();
        }

        if (window.graphInterval) {
          console.log("âœ… fetchLatestTankDataForGraphì˜ setInterval ì¤‘ë‹¨");
          cancelAnimationFrame(window.graphInterval);
          window.graphInterval = null;
        }

        const valueKeyMap = {
          'chart-1': 'ph',
          'chart-2': 'do',
          'chart-3': 'temp',
          'chart-4': 'salt',
          'chart-5': 'ammonia',
          'chart-6': 'nitrogen'
        };
        const labelMap = {
          'chart-1': 'ì‚°ì„±ë„',
          'chart-2': 'ìš©ì¡´ì‚°ì†Œ',
          'chart-3': 'ìˆ˜ì˜¨',
          'chart-4': 'ì—¼ë„',
          'chart-5': 'ì•”ëª¨ë‹ˆì•„',
          'chart-6': 'ì•„ì§ˆì‚°'
        };
        const dataKey = valueKeyMap[chartId];
        const label = labelMap[chartId];
        const rangeIndex = chartIndexMap[chartId];
        const range = ranges[rangeIndex];

        const labels = [];
        const values = [];
        dataArray.forEach(item => {
          if (item.data && item.data.length > 0) {
            item.data.forEach(entry => {
              labels.push(`${item.date} ${entry.timestamp || ''}`);
              const value = entry[dataKey] !== undefined && entry[dataKey] !== null ? entry[dataKey] : 0;
              values.push(value);
            });
          }
        });

        console.log(`êº¾ì€ì„  ê·¸ë˜í”„ ë°ì´í„° (${label}):`, { labels, values });

        if (labels.length === 0 || values.length === 0) {
          console.warn(`âš ï¸ í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤ - chartId: ${chartId}`);
          displayNoDataMessage();
          return;
        }

        const pointColors = values.map(value => {
          const color = getColor(value, range);
          console.log(`ğŸ“Š ë°ì´í„° í¬ì¸íŠ¸ - ê°’: ${value}, ìƒíƒœ: ${color.status}`);
          return color;
        });

        const pointBorderColors = pointColors.map(color => color.border);
        const pointBackgroundColors = pointColors.map(color => color.background);

        const dateRangeText = selectedDateRange
          ? `${formatDateToLocal(selectedDateRange.start)} ~ ${formatDateToLocal(selectedDateRange.end)}`
          : "ì„ íƒëœ ë‚ ì§œ";
        console.log(`âœ… í‘œì‹œëœ ë‚ ì§œ ë²”ìœ„: ${dateRangeText}`);

        try {
          realtimeChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [{
                label: `ë°ì´í„° (${dateRangeText})`,
                data: values,
                borderColor: '#66BB6A', // ê¸°ë³¸ ìƒ‰ìƒ
                backgroundColor: 'rgba(0, 0, 0, 0)',
                fill: false,
                tension: 0.4,
                pointRadius: 5,
                pointBorderColor: pointBorderColors,
                pointBackgroundColor: pointBackgroundColors,
                borderWidth: 3,
                segment: {
                  borderColor: (ctx) => {
                    const p0 = ctx.p0;
                    const p1 = ctx.p1;
                    if (!p0 || !p1) return '#66BB6A';
                    const p0Color = pointColors[p0.$context.dataIndex];
                    const p1Color = pointColors[p1.$context.dataIndex];
                    // ë‘ í¬ì¸íŠ¸ ì¤‘ í•˜ë‚˜ë¼ë„ ê²½ê³  ìƒíƒœë©´ ë¹¨ê°„ìƒ‰
                    return (p0Color.status === 'warning' || p1Color.status === 'warning') ? '#E57373' : '#66BB6A';
                  }
                }
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: {
                duration: 500,
                easing: 'easeOutCubic'
              },
              scales: {
                x: {
                  title: { display: true, color: "#ffffff", font: { size: 14 } },
                  ticks: { color: "#ffffff", font: { size: 12 } }
                },
                y: {
                  ticks: { color: "#ffffff", font: { size: 12 } },
                  beginAtZero: true
                }
              },
              plugins: {
                legend: { display: false },
                title: { display: true, text: `${label} ë°ì´í„° (${dateRangeText})`, color: "#ffffff", font: { size: 16 }, padding: { top: 10, bottom: 20 } }
              }
            }
          });
          console.log(`âœ… realtimeChart ìƒì„± ì™„ë£Œ - chartId: ${chartId}`);
        } catch (error) {
          console.error(`âŒ realtimeChart ìƒì„± ì‹¤íŒ¨ - chartId: ${chartId}`, error);
          displayNoDataMessage();
          return;
        }

        isAverageMode = false;
      }

      // ì‹¤ì‹œê°„ ê·¸ë˜í”„ ë³µì›
      function resetToRealtimeGraph() {
        const ctx = document.getElementById("aihubGraph").getContext("2d");
        if (realtimeChart) {
          console.log("âœ… ê¸°ì¡´ realtimeChart ì œê±°");
          realtimeChart.destroy();
        }

        if (window.graphInterval) {
          console.log("âœ… fetchLatestTankDataForGraphì˜ setInterval ì¤‘ë‹¨");
          cancelAnimationFrame(window.graphInterval);
          window.graphInterval = null;
        }

        realtimeChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: [],
            datasets: [{
              label: "ë°ì´í„° ì—†ìŒ",
              data: [],
              borderColor: "#4A90E2",
              backgroundColor: "rgba(74, 144, 226, 0.2)",
              fill: true,
              tension: 0.4
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
              duration: 500,
              easing: 'easeOutCubic'
            },
            scales: {
              x: { title: { display: true, text: "ì‹¤ì‹œê°„ ë°ì´í„°", color: "#ffffff" }, ticks: { color: "#ffffff" } },
              y: { ticks: { color: "#ffffff" } }
            },
            plugins: {
              legend: { display: false },
              title: { display: true, text: "ì‹¤ì‹œê°„ ë°ì´í„°", color: "#ffffff", font: { size: 16 } }
            }
          }
        });
        isAverageMode = false;
      }

      // ì‹¤ì‹œê°„ ê·¸ë˜í”„ ì¬ì‹œì‘ (ì´ˆê¸°í™” ì—†ì´)
      function resumeRealtimeGraph(chartId, label) {
        if (!realtimeChart) {
          // ê·¸ë˜í”„ê°€ ì—†ëŠ” ê²½ìš° ìƒˆë¡œ ìƒì„±
          showGraphFor(chartId, label);
          return;
        }

        // ê¸°ì¡´ ê·¸ë˜í”„ê°€ ìˆìœ¼ë©´ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë§Œ ì¬ì‹œì‘
        const valueKeyMap = {
          'chart-1': 'waterPh', 'chart-2': 'waterDo', 'chart-3': 'waterTemp',
          'chart-4': 'waterSalt', 'chart-5': 'waterAmmonia', 'chart-6': 'waterNitrogen'
        };
        const dataKey = valueKeyMap[chartId];

        if (window.graphInterval) {
          console.log("âœ… fetchLatestTankDataForGraphì˜ setInterval ì¤‘ë‹¨");
          cancelAnimationFrame(window.graphInterval);
          window.graphInterval = null;
        }

        // ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ ì¬ì‹œì‘
        animationProgressMap[chartId] = 0;
        const updateLoop = () => {
          fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], smoothedValuesMap[chartId], realtimeChart);
          window.graphInterval = requestAnimationFrame(updateLoop);
        };
        window.graphInterval = requestAnimationFrame(updateLoop);

        console.log(`âœ… ì‹¤ì‹œê°„ ê·¸ë˜í”„ ì¬ì‹œì‘ - chartId: ${chartId}`);
      }

      // ì „ì—­ ë³€ìˆ˜ ì •ì˜
      const dataRanges = {
        'chart-1': { min: 7.3, max: 9.2, label: 'pH' },
        'chart-2': { min: 5.0, max: 15.0, label: 'Oâ‚‚ (mg/L)' },
        'chart-3': { min: 24.77, max: 31.0, label: 'Â°C' },
        'chart-4': { min: 0.5, max: 47.0, label: 'ppt' },
        'chart-5': { min: 0.0, max: 0.5, label: 'NHâ‚ƒ (mg/L)' },
        'chart-6': { min: 0.0, max: 5.2, label: 'NOâ‚‚ (mg/L)' },
      };

      let gaugeValues = {
        'chart-1': null,
        'chart-2': null,
        'chart-3': null,
        'chart-4': null,
        'chart-5': null,
        'chart-6': null,
      };

      const canvasElements = [
        document.getElementById('chart-1'),
        document.getElementById('chart-2'),
        document.getElementById('chart-3'),
        document.getElementById('chart-4'),
        document.getElementById('chart-5'),
        document.getElementById('chart-6'),
      ];

      const angles = {
        'chart-1': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        'chart-2': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        'chart-3': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        'chart-4': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        'chart-5': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
        'chart-6': { current: Math.PI + (50 / 100) * Math.PI, target: Math.PI + (50 / 100) * Math.PI },
      };

      const animationStates = {
        'chart-1': { animating: false },
        'chart-2': { animating: false },
        'chart-3': { animating: false },
        'chart-4': { animating: false },
        'chart-5': { animating: false },
        'chart-6': { animating: false },
      };

      const ranges = [
        { warning1Min: 7.3, warning1Max: 7.49, normalMin: 7.5, normalMax: 9.0, warning2Min: 9.1, warning2Max: 9.2, min: 7.3, max: 9.2 },
        { warning1Min: null, warning1Max: null, normalMin: 5.0, normalMax: 10.0, warning2Min: 10.1, warning2Max: 15.0, min: 3.0, max: 15.0 },
        { warning1Min: 24.77, warning1Max: 25.9, normalMin: 26.0, normalMax: 30.0, warning2Min: 30.1, warning2Max: 31.0, min: 24.77, max: 31.0 },
        { warning1Min: null, warning1Max: null, normalMin: 0.5, normalMax: 45.0, warning2Min: 45.1, warning2Max: 47.0, min: 0.5, max: 47.0 },
        { warning1Min: null, warning1Max: null, normalMin: 0.0, normalMax: 0.16, warning2Min: 0.3, warning2Max: 0.5, min: 0.0, max: 0.5 },
        { warning1Min: null, warning1Max: null, normalMin: 0.0, normalMax: 5.0, warning2Min: 5.1, warning2Max: 5.2, min: 0.0, max: 5.2 }
      ];

      const chartIndexMap = { 'chart-1': 0, 'chart-2': 1, 'chart-3': 2, 'chart-4': 3, 'chart-5': 4, 'chart-6': 5 };

      // tankIdxMapì„ ë™ì ìœ¼ë¡œ ì„¤ì •
      const urlParams = new URLSearchParams(window.location.search);
      const tankIdx = urlParams.get("tankIdx") || '1';
      const tankIdxMap = {
        'chart-1': tankIdx,
        'chart-2': tankIdx,
        'chart-3': tankIdx,
        'chart-4': tankIdx,
        'chart-5': tankIdx,
        'chart-6': tankIdx,
      };

      function getDataItem(chartId, tankIdx) {
        const dataItems = {
          'chart-1': document.getElementById(`ph-item-${tankIdx}`),
          'chart-2': document.getElementById(`do-item-${tankIdx}`),
          'chart-3': document.getElementById(`temp-item-${tankIdx}`),
          'chart-4': document.getElementById(`salt-item-${tankIdx}`),
          'chart-5': document.getElementById(`ammonia-item-${tankIdx}`),
          'chart-6': document.getElementById(`nitrogen-item-${tankIdx}`),
        };
        return dataItems[chartId];
      }

      function getColor(value, range) {
        if (value === null || isNaN(value)) value = (range.normalMin + range.normalMax) / 2;
        if (range.warning1Min !== null && range.warning1Max !== null && value >= range.warning1Min && value <= range.warning1Max)
          return { background: '#ff4500', border: '#ff7f7f', status: 'warning' };
        if (value >= range.normalMin && value <= range.normalMax)
          return { background: '#32cd32', border: '#90ee90', status: 'normal' };
        if (range.warning2Min !== null && range.warning2Max !== null && value >= range.warning2Min && value <= range.warning2Max)
          return { background: '#ff4500', border: '#ff7f7f', status: 'warning' };
        if ((value > range.normalMax && (range.warning2Min === null || value < range.warning2Min)) || 
            (range.warning2Max !== null && value > range.warning2Max))
          return { background: '#ff4500', border: '#ff7f7f', status: 'warning' };
        if (value < range.normalMin && (range.warning1Min === null || value < range.warning1Min))
          return { background: '#ff4500', border: '#ff7f7f', status: 'warning' };
        return { background: '#ff4500', border: '#ff7f7f', status: 'warning' };
      }

      function easeOutQuad(t) {
        return 1 - (1 - t) * (1 - t);
      }

      function updateGauge(chartId, value, min, max) {
        const rangeIndex = chartIndexMap[chartId];
        const range = ranges[rangeIndex];
        if (value === null || value === undefined || isNaN(value)) value = (range.normalMin + range.normalMax) / 2;
        value = Math.max(range.min, Math.min(range.max, value));
        gaugeValues[chartId] = value;

        const totalAngle = Math.PI, startAngle = Math.PI, sectionAngle = totalAngle / 3;
        let targetAngle;

        if (value < range.normalMin) {
          if (range.warning1Min !== null && range.warning1Max !== null) {
            const warning1Range = range.normalMin - range.warning1Min;
            const warning1Ratio = (value - range.warning1Min) / warning1Range;
            targetAngle = startAngle + warning1Ratio * sectionAngle;
          } else targetAngle = startAngle;
        } else if (value > range.normalMax) {
          if (range.warning2Min !== null && range.warning2Max !== null) {
            const warning2Range = range.warning2Max - range.normalMax;
            const warning2Ratio = (value - range.normalMax) / warning2Range;
            targetAngle = startAngle + 2 * sectionAngle + warning2Ratio * sectionAngle;
          } else targetAngle = startAngle + 2 * sectionAngle;
        } else {
          const normalRange = range.normalMax - range.normalMin;
          const normalRatio = (value - range.normalMin) / normalRange;
          targetAngle = startAngle + sectionAngle + normalRatio * sectionAngle;
        }

        targetAngle = Math.max(Math.PI, Math.min(2 * Math.PI, targetAngle));
        angles[chartId].target = targetAngle;

        const tankIdx = tankIdxMap[chartId];
        const dataItem = getDataItem(chartId, tankIdx);
        const colors = getColor(value, range);
        if (dataItem) {
          if (colors.status === 'warning') dataItem.classList.add('blink-data-item');
          else dataItem.classList.remove('blink-data-item');
        }

        if (!animationStates[chartId].animating) {
          animationStates[chartId].animating = true;
          animateGauge(chartId);
        }
      }

      function animateGauge(chartId) {
        const canvas = document.getElementById(chartId);
        const ctx = canvas.getContext("2d");
        const canvasWidth = canvas.width, canvasHeight = canvas.height;
        const startAngle = angles[chartId].current, targetAngle = angles[chartId].target;
        const duration = 600;
        let startTime = null;

        function step(timestamp) {
          if (!startTime) startTime = timestamp;
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const easedProgress = easeOutBack(progress);

          angles[chartId].current = startAngle + (targetAngle - startAngle) * easedProgress;
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);
          drawGaugeOnCanvas(chartId, canvas);

          const centerX = canvasWidth / 2, centerY = canvasHeight - 50, len = 80;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(centerX + Math.cos(angles[chartId].current) * len, centerY + Math.sin(angles[chartId].current) * len);
          ctx.strokeStyle = 'red';
          ctx.lineWidth = 4;
          ctx.stroke();

          if (progress < 1) requestAnimationFrame(step);
          else animationStates[chartId].animating = false;
        }

        requestAnimationFrame(step);
      }

      function easeOutBack(t) {
        const c1 = 1.2, c3 = c1 + 1;
        return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
      }

      function drawGaugeOnCanvas(canvasId, canvas) {
        const ctx = canvas.getContext('2d');
        const canvasWidth = canvas.width, canvasHeight = canvas.height;
        const centerX = canvasWidth / 2, centerY = canvasHeight - 50, radius = 100, gaugeWidth = 30;

        const colors = { warning1: ['#ff4500', '#ff7f7f'], normal: ['#32cd32', '#90ee90'], warning2: ['#ff4500', '#ff7f7f'] };
        const labels = { warning1: 'ê²½ê³ ', normal: 'ì •ìƒ', warning2: 'ê²½ê³ ' };
        const rangeIndex = chartIndexMap[canvasId];
        const range = ranges[rangeIndex];

        function drawGauge() {
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);
          const totalAngle = Math.PI, startAngle = Math.PI, sectionAngle = totalAngle / 3;
          let currentAngle = startAngle;

          ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
          ctx.shadowBlur = 10;
          ctx.lineWidth = 2;
          drawSection(currentAngle, sectionAngle, colors.warning1);
          currentAngle += sectionAngle;
          drawSection(currentAngle, sectionAngle, colors.normal);
          currentAngle += sectionAngle;
          drawSection(currentAngle, sectionAngle, colors.warning2);

          ctx.shadowBlur = 0;
          drawLabels(startAngle, sectionAngle);
        }

        function drawSection(start, angle, colorPair) {
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, start, start + angle);
          ctx.arc(centerX, centerY, radius - gaugeWidth, start + angle, start, true);
          ctx.closePath();
          ctx.fillStyle = colorPair[0];
          ctx.fill();
          ctx.strokeStyle = '#333';
          ctx.stroke();
        }

        function drawLabels(startAngle, sectionAngle) {
          const labelRadius = radius - gaugeWidth / 2;
          ctx.fillStyle = '#000';
          ctx.font = 'bold 15px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const angles = [
            startAngle + sectionAngle / 2,
            startAngle + sectionAngle + sectionAngle / 2,
            startAngle + sectionAngle * 2 + sectionAngle / 2
          ];
          const texts = [labels.warning1, labels.normal, labels.warning2];

          angles.forEach((angle, i) => {
            const x = centerX + Math.cos(angle) * labelRadius;
            const y = centerY + Math.sin(angle) * labelRadius;
            ctx.fillText(texts[i], x, y);
          });
        }

        drawGauge();
      }

      canvasElements.forEach(canvas => drawGaugeOnCanvas(canvas.id, canvas));

      async function fetchLatestTankData(tankIdx) {
        try {
          const response = await fetch(`/tank/data/latest?tankIdx=${tankIdx}`);
          if (!response.ok) throw new Error(`HTTP ì˜¤ë¥˜: ${response.status}`);
          const data = await response.json();
          console.log("âœ… ìµœì‹  ìˆ˜ì¡° ë°ì´í„° ë¡œë“œ ì™„ë£Œ:", data);
          return data;
        } catch (error) {
          console.error("âŒ ìˆ˜ì¡° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:", error);
          const defaultData = {
            waterPh: (ranges[0].normalMin + ranges[0].normalMax) / 2,
            waterDo: (ranges[1].normalMin + ranges[1].normalMax) / 2,
            waterTemp: (ranges[2].normalMin + ranges[2].normalMax) / 2,
            waterSalt: (ranges[3].normalMin + ranges[3].normalMax) / 2,
            waterAmmonia: (ranges[4].normalMin + ranges[4].normalMax) / 2,
            waterNitrogen: (ranges[5].normalMin + ranges[5].normalMax) / 2
          };
          console.warn("âš ï¸ ì„œë²„ì—ì„œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í•´ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •:", defaultData);
          return defaultData;
        }
      }

      async function updateTankData(tankIdx) {
        const latestData = await fetchLatestTankData(tankIdx);
        if (latestData) {
          const dataValues = [
            parseFloat(latestData.waterPh),
            parseFloat(latestData.waterDo),
            parseFloat(latestData.waterTemp),
            parseFloat(latestData.waterSalt),
            parseFloat(latestData.waterAmmonia),
            parseFloat(latestData.waterNitrogen)
          ];

          const textElements = [
            document.getElementById(`ph-${tankIdx}`),
            document.getElementById(`do-${tankIdx}`),
            document.getElementById(`temp-${tankIdx}`),
            document.getElementById(`salt-${tankIdx}`),
            document.getElementById(`ammonia-${tankIdx}`),
            document.getElementById(`nitrogen-${tankIdx}`)
          ];

          const dataItems = [
            document.getElementById(`ph-item-${tankIdx}`),
            document.getElementById(`do-item-${tankIdx}`),
            document.getElementById(`temp-item-${tankIdx}`),
            document.getElementById(`salt-item-${tankIdx}`),
            document.getElementById(`ammonia-item-${tankIdx}`),
            document.getElementById(`nitrogen-item-${tankIdx}`)
          ];

          dataValues.forEach((value, index) => {
            const chartId = `chart-${index + 1}`;
            updateGauge(chartId, value, dataRanges[chartId].min, dataRanges[chartId].max);

            if (textElements[index]) {
              const formattedValue = value ? value.toFixed(2) : '-'; // ì†Œìˆ˜ì  2ìë¦¬ë¡œ ê³ ì •
              textElements[index].textContent = formattedValue;
              const colors = getColor(value, ranges[index]);
              textElements[index].style.color = colors.border;
            }

            if (dataItems[index]) {
              const colors = getColor(value, ranges[index]);
              if (colors.status === 'warning') {
                dataItems[index].classList.add('blink-data-item');
              } else {
                dataItems[index].classList.remove('blink-data-item');
              }
            }
          });
        }
      }

      updateTankData(tankIdx);
      setInterval(() => updateTankData(tankIdx), 700);

      const cardElements = document.querySelectorAll('.card');

      cardElements.forEach(card => {
        const canvas = card.querySelector('canvas');
        const chartId = canvas.id;
        labelsMap[chartId] = [];
        valuesMap[chartId] = [];
        smoothedValuesMap[chartId] = [];
        animationProgressMap[chartId] = 0;

        card.addEventListener('click', () => {
          cardElements.forEach(c => c.classList.remove('clicked', 'animate-click'));
          card.classList.add('clicked', 'animate-click');
          setTimeout(() => card.classList.remove('animate-click'), 300);
          selectedChartId = chartId;
          const label = dataRanges[chartId].label;
          if (isAverageMode) {
            isAverageMode = false;
          }
          showGraphFor(chartId, label);
        });
      });

      // ì´ˆê¸° ìƒíƒœ: ë¹ˆ ê·¸ë˜í”„ í‘œì‹œ
      resetToRealtimeGraph();

      // ì»¤ìŠ¤í…€ í”ŒëŸ¬ê·¸ì¸: ë¶€ë“œëŸ¬ìš´ íë¦„ íš¨ê³¼
      const flowEffectPlugin = {
        id: 'flowEffect',
        beforeDatasetsDraw(chart) {
          const { ctx, data, chartArea } = chart;
          const dataset = data.datasets[0];
          const meta = chart.getDatasetMeta(0);
          const points = meta.data;

          if (points.length < 2) return;

          ctx.save();
          const animationProgress = chart.options.animationProgress || 0;
          const waveOffset = Math.sin(animationProgress * Math.PI) * 2; // ì§„í­ ì¤„ì„

          ctx.beginPath();
          ctx.lineWidth = 4; // ì„  ë‘ê»˜ ì¦ê°€
          ctx.fillStyle = 'rgba(102, 187, 106, 0.05)'; // ì±„ìš°ê¸° íˆ¬ëª…ë„ ë‚®ì¶¤

          const firstPoint = points[0];
          ctx.moveTo(firstPoint.x, firstPoint.y + waveOffset);

          for (let i = 1; i < points.length; i++) {
            const point = points[i];
            const prevPoint = points[i - 1];
            const midX = (prevPoint.x + point.x) / 2;
            const midY = (prevPoint.y + point.y) / 2 + Math.sin((i + animationProgress) * Math.PI) * 1; // ë¯¸ì„¸í•œ íŒŒë™
            ctx.quadraticCurveTo(prevPoint.x, prevPoint.y + waveOffset, midX, midY);
          }

          ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y + waveOffset);
          ctx.stroke();

          // ì±„ìš°ê¸°
          ctx.lineTo(points[points.length - 1].x, chartArea.bottom);
          ctx.lineTo(points[0].x, chartArea.bottom);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }
      };

      Chart.register(flowEffectPlugin);

      function showGraphFor(chartId, label) {
    	  const ctx = document.getElementById('aihubGraph').getContext('2d');
    	  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”

    	  const valueKeyMap = {
    	    'chart-1': 'waterPh', 'chart-2': 'waterDo', 'chart-3': 'waterTemp',
    	    'chart-4': 'waterSalt', 'chart-5': 'waterAmmonia', 'chart-6': 'waterNitrogen'
    	  };
    	  const dataKey = valueKeyMap[chartId];

    	  if (realtimeChart) {
    	    console.log("âœ… ê¸°ì¡´ realtimeChart ì œê±°");
    	    realtimeChart.destroy();
    	  }

    	  if (window.graphInterval) {
    	    console.log("âœ… fetchLatestTankDataForGraphì˜ setInterval ì¤‘ë‹¨");
    	    cancelAnimationFrame(window.graphInterval);
    	    window.graphInterval = null;
    	  }

    	  try {
    	    realtimeChart = new Chart(ctx, {
    	      type: 'line',
    	      data: {
    	        labels: labelsMap[chartId] || [],
    	        datasets: [{
    	          label: `${label} ì‹¤ì‹œê°„ ë°ì´í„°`,
    	          data: smoothedValuesMap[chartId] || [],
    	          borderColor: '#66BB6A',
    	          backgroundColor: 'rgba(102, 187, 106, 0.05)',
    	          fill: true,
    	          tension: 0.5, // ê³¡ì„  ë” ë¶€ë“œëŸ½ê²Œ
    	          pointRadius: 3,
    	          pointBorderColor: '#ffffff',
    	          pointBackgroundColor: (ctx) => {
    	            const index = ctx.dataIndex;
    	            const value = ctx.dataset.data[index];
    	            const rangeIndex = chartIndexMap[chartId];
    	            const range = ranges[rangeIndex];
    	            const colors = getColor(value, range);
    	            return colors.status === 'warning' ? '#E57373' : '#66BB6A';
    	          },
    	          borderWidth: 4,
    	          segment: {
    	            borderColor: (ctx) => {
    	              const p0 = ctx.p0;
    	              const p1 = ctx.p1;
    	              if (!p0 || !p1) return '#66BB6A';
    	              const p0Value = p0.parsed.y;
    	              const p1Value = p1.parsed.y;
    	              const rangeIndex = chartIndexMap[chartId];
    	              const range = ranges[rangeIndex];
    	              const p0Color = getColor(p0Value, range);
    	              const p1Color = getColor(p1Value, range);
    	              return (p0Color.status === 'warning' || p1Color.status === 'warning') ? '#E57373' : '#66BB6A';
    	            }
    	          }
    	        }]
    	      },
    	      options: {
    	        responsive: true,
    	        maintainAspectRatio: false,
    	        animation: {
    	          duration: 700,
    	          easing: 'easeOutCubic'
    	        },
    	        scales: {
    	          x: { 
    	            title: { display: true, text: 'ì‹¤ì‹œê°„ ë°ì´í„°', color: '#ffffff', font: { size: 14 } }, 
    	            ticks: { color: '#ffffff', font: { size: 12 } },
    	            grid: { display: false }
    	          },
    	          y: { 
    	            ticks: { color: "#ffffff", font: { size: 12 } },
    	            grid: { color: 'rgba(255, 255, 255, 0.1)' }
    	          }
    	        },
    	        plugins: {
    	          legend: { display: false },
    	          title: { display: true, text: label, color: '#ffffff', font: { size: 16 }, padding: { top: 10, bottom: 20 } },
    	          flowEffect: false // í”ŒëŸ¬ê·¸ì¸ ë¹„í™œì„±í™”
    	        }
    	      }
    	    });
    	    console.log(`âœ… realtimeChart ìƒì„± ì™„ë£Œ - chartId: ${chartId}`);
    	  } catch (error) {
    	    console.error(`âŒ realtimeChart ìƒì„± ì‹¤íŒ¨ - chartId: ${chartId}`, error);
    	    return;
    	  }

    	  if (realtimeChart) {
    	    if (!labelsMap[chartId]) labelsMap[chartId] = [];
    	    if (!valuesMap[chartId]) valuesMap[chartId] = [];
    	    if (!smoothedValuesMap[chartId]) smoothedValuesMap[chartId] = [];

    	    const updateLoop = () => {
    	      fetchLatestTankDataForGraph(chartId, dataKey, labelsMap[chartId], valuesMap[chartId], smoothedValuesMap[chartId], realtimeChart);
    	      realtimeChart.update(); // ì°¨íŠ¸ ê°•ì œ ê°±ì‹ 
    	      window.graphInterval = requestAnimationFrame(updateLoop);
    	    };
    	    window.graphInterval = requestAnimationFrame(updateLoop);
    	  } else {
    	    console.error("âŒ realtimeChartê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì¤‘ë‹¨.");
    	  }
    	}

      // ë°ì´í„° ìŠ¤ë¬´ë”© í•¨ìˆ˜ (ì§€ìˆ˜ ì´ë™ í‰ê· , EMA)
      function smoothData(chartId, newValue) {
        const alpha = 0.1; // ìŠ¤ë¬´ë”© ê³„ìˆ˜
        const smoothedValues = smoothedValuesMap[chartId];
        const values = valuesMap[chartId];

        if (smoothedValues.length === 0) {
          smoothedValues.push(newValue);
        } else {
          const lastSmoothed = smoothedValues[smoothedValues.length - 1];
          const smoothedValue = alpha * newValue + (1 - alpha) * lastSmoothed;
          smoothedValues.push(smoothedValue);
        }

        // ì›ë³¸ ë°ì´í„°ë„ ì €ì¥
        values.push(newValue);

        // ë°ì´í„° ê¸¸ì´ ì œí•œ
        if (smoothedValues.length > 15) {
          smoothedValues.shift();
          values.shift();
        }

        return smoothedValues;
      }

      let lastUpdateTime = 0;
      const updateInterval = 700; // 700ms ê°„ê²©ìœ¼ë¡œ ë°ì´í„° ì—…ë°ì´íŠ¸

      function fetchLatestTankDataForGraph(chartId, dataKey, labels, values, smoothedValues, chart) {
        const now = performance.now();
        if (now - lastUpdateTime < updateInterval) return; // ì—…ë°ì´íŠ¸ ê°„ê²© ì œí•œ
        lastUpdateTime = now;

        const urlParams = new URLSearchParams(window.location.search);
        const tankIdx = urlParams.get("tankIdx");

        if (!chart || !chart.data || !chart.data.datasets || !chart.data.datasets[0]) {
          console.error(`âŒ chart ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤ - chartId: ${chartId}`, chart);
          return;
        }

        if (tankIdx) {
          fetch(`/tank/data/latest?tankIdx=${tankIdx}`)
            .then(response => response.json())
            .then(data => {
              console.log(`âœ… ìµœì‹  ë°ì´í„° ë¡œë“œ ì„±ê³µ - chartId: ${chartId}, data:`, data);
              let value = parseFloat(data[dataKey]);
              const now = new Date();
              const timeLabel = now.toLocaleTimeString();

              if (!isNaN(value)) {
                value = parseFloat(value.toFixed(2)); // ì†Œìˆ˜ì  2ìë¦¬ë¡œ ê³ ì •
                labels.push(timeLabel);

                // ë°ì´í„° ìŠ¤ë¬´ë”© ì ìš©
                const smoothedData = smoothData(chartId, value);

                if (labels.length > 15) {
                  labels.shift();
                }

                const rangeIndex = chartIndexMap[chartId];
                const range = ranges[rangeIndex];
                const colors = getColor(value, range);

                if (chart && chart.data && chart.data.datasets && chart.data.datasets[0]) {
                  chart.data.labels = labels;
                  chart.data.datasets[0].data = smoothedData;
                  chart.data.datasets[0].pointBackgroundColor = smoothedData.map(val => {
                    const colors = getColor(val, range);
                    return colors.status === 'warning' ? '#E57373' : '#66BB6A';
                  });
                  chart.options.animationProgress = (chart.options.animationProgress || 0) + 0.03;
                  chart.update({
                    duration: 700,
                    easing: 'easeOutCubic'
                  });
                  console.log(`âœ… ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ - chartId: ${chartId}, value: ${value}, smoothed: ${smoothedData[smoothedData.length - 1]}`);
                } else {
                  console.error(`âŒ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: chart ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ - chartId: ${chartId}`);
                }
              } else {
                console.warn(`âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ - ${dataKey}: ${data[dataKey]}`);
                const rangeIndex = chartIndexMap[chartId];
                const range = ranges[rangeIndex];
                const defaultValue = parseFloat(((range.normalMin + range.normalMax) / 2).toFixed(2));
                labels.push(timeLabel);

                // ë°ì´í„° ìŠ¤ë¬´ë”© ì ìš©
                const smoothedData = smoothData(chartId, defaultValue);

                if (labels.length > 15) {
                  labels.shift();
                }

                const colors = getColor(defaultValue, range);
                if (chart && chart.data && chart.data.datasets && chart.data.datasets[0]) {
                  chart.data.labels = labels;
                  chart.data.datasets[0].data = smoothedData;
                  chart.data.datasets[0].pointBackgroundColor = smoothedData.map(val => {
                    const colors = getColor(val, range);
                    return colors.status === 'warning' ? '#E57373' : '#66BB6A';
                  });
                  chart.options.animationProgress = (chart.options.animationProgress || 0) + 0.03;
                  chart.update({
                    duration: 700,
                    easing: 'easeOutCubic'
                  });
                  console.log(`âœ… ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ (ê¸°ë³¸ê°’ ì‚¬ìš©) - chartId: ${chartId}, defaultValue: ${defaultValue}`);
                } else {
                  console.error(`âŒ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ê¸°ë³¸ê°’): chart ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ - chartId: ${chartId}`);
                }
              }
            })
            .catch(err => {
              console.error(`âŒ ê·¸ë˜í”„ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨ - chartId: ${chartId}:`, err);
              const now = new Date();
              const timeLabel = now.toLocaleTimeString();
              const rangeIndex = chartIndexMap[chartId];
              const range = ranges[rangeIndex];
              const defaultValue = parseFloat(((range.normalMin + range.normalMax) / 2).toFixed(2));

              labels.push(timeLabel);

              // ë°ì´í„° ìŠ¤ë¬´ë”© ì ìš©
              const smoothedData = smoothData(chartId, defaultValue);

              if (labels.length > 15) {
                labels.shift();
              }

              const colors = getColor(defaultValue, range);
              if (chart && chart.data && chart.data.datasets && chart.data.datasets[0]) {
                chart.data.labels = labels;
                chart.data.datasets[0].data = smoothedData;
                chart.data.datasets[0].pointBackgroundColor = smoothedData.map(val => {
                  const colors = getColor(val, range);
                  return colors.status === 'warning' ? '#E57373' : '#66BB6A';
                });
                chart.options.animationProgress = (chart.options.animationProgress || 0) + 0.03;
                chart.update({
                  duration: 700,
                  easing: 'easeOutCubic'
                });
                console.log(`âœ… ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì™„ë£Œ (ì—ëŸ¬ ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©) - chartId: ${chartId}, defaultValue: ${defaultValue}`);
              } else {
                console.error(`âŒ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ì—ëŸ¬ ì‹œ): chart ê°ì²´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ - chartId: ${chartId}`);
              }
            });
        } else {
          console.warn(`âš ï¸ tankIdxê°€ ì—†ìŠµë‹ˆë‹¤. ë°ì´í„° ìš”ì²­ ì¤‘ë‹¨ - chartId: ${chartId}`);
        }
      }
    });
  </script>
</body>
</html>